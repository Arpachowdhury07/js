import { Details, createMetadata } from "@doc";

export const metadata = createMetadata({
	title: "IThirdwebWallet.SignAuthorization | Tercero .NET SDK",
	description: "Firma un payload EIP-7702 para establecer código en tu EOA.",
});

# [EIP-7702](https://eips.ethereum.org/EIPS/eip-7702) Integración (Experimental)
Integra `authorizationList` para cualquier transacción.
Este EIP esencialmente te permite establecer código en un EOA, desbloqueando un mundo de posibilidades para mejorar su funcionalidad.

La mejor manera de entenderlo, fuera de leer el EIP, es ver el ejemplo a continuación; para preámbulo: firmamos una autorización usando la billetera a la que queremos establecer el código. Otra billetera envía una transacción con dicha autorización incluida, esencialmente activándola. La billetera de autoridad ahora tiene un código establecido que apunta a un contrato de (insegura) [Delegación](https://thirdweb.com/odyssey-911867/0x654F42b74885EE6803F403f077bc0409f1066c58) en este caso, lo que permite que cualquier billetera ejecute cualquier llamada a través de ella en nombre de la autoridad. En este ejemplo, llamamos a la billetera que ejecuta tanto la autorización como la transacción de reclamación después, el ejecutor.

Una autoridad puede ejecutar su propia autorización, la única diferencia es interna, donde el nonce de autorización se incrementa en 1.

```csharp
// Direcciones de cadena y contrato
var cadenaCon7702 = 911867;
var direccionContratoERC20 = "0xAA462a5BE0fc5214507FDB4fB2474a7d5c69065b"; // ERC20 falso
var direccionContratoDelegacion = "0x654F42b74885EE6803F403f077bc0409f1066c58"; // BatchCallDelegation

// Inicializa los contratos normalmente
var contratoERC20 = await ThirdwebContract.Create(client: client, address: direccionContratoERC20, chain: cadenaCon7702);
var contratoDelegacion = await ThirdwebContract.Create(client: client, address: direccionContratoDelegacion, chain: cadenaCon7702);

// Inicializa un EOA (cuenta de usuario externa) (por configurar)
var billeteraEOA = await PrivateKeyWallet.Generate(client);
var direccionBilleteraEOA = await billeteraEOA.GetAddress();
Console.WriteLine($"Dirección de EOA: {direccionBilleteraEOA}");

// Inicializa otra billetera, el "ejecutor" que ejecutará la función de ejecución de la billetera EOA (por configurar)
var billeteraEjecutor = await PrivateKeyWallet.Generate(client);
var direccionBilleteraEjecutor = await billeteraEjecutor.GetAddress();
Console.WriteLine($"Dirección del ejecutor: {direccionBilleteraEjecutor}");

// Financiar la billetera del ejecutor
var billeteraFinanciadora = await PrivateKeyWallet.Create(client, privateKey);
var hashDeFinanciacion = (await billeteraFinanciadora.Transfer(cadenaCon7702, direccionBilleteraEjecutor, BigInteger.Parse("0.001".ToWei()))).TransactionHash;
Console.WriteLine($"Billetera del ejecutor financiada: {hashDeFinanciacion}");

// Firmar la autorización para que apunte al contrato de delegación
var autorizacion = await billeteraEOA.SignAuthorization(chainId: cadenaCon7702, contractAddress: direccionContratoDelegacion, willSelfExecute: false);
Console.WriteLine($"Autorización: {JsonConvert.SerializeObject(autorizacion, Formatting.Indented)}");

// Ejecutar la delegación
var tx = await ThirdwebTransaction.Create(billeteraEjecutor, new ThirdwebTransactionInput(chainId: cadenaCon7702, to: direccionBilleteraEjecutor, authorization: autorizacion));
var hash = (await ThirdwebTransaction.SendAndWaitForTransactionReceipt(tx)).TransactionHash;
Console.WriteLine($"Hash de la transacción de ejecución de autorización: {hash}");

// Probar que el código se ha desplegado en el EOA
var rpc = ThirdwebRPC.GetRpcInstance(client, cadenaCon7702);
var codigo = await rpc.SendRequestAsync<string>("eth_getCode", direccionBilleteraEOA, "latest");
Console.WriteLine($"Código del EOA: {codigo}");

// Registrar el saldo ERC20 del ejecutor antes de la reclamación
var saldoEjecutorAntes = await contratoERC20.ERC20_BalanceOf(direccionBilleteraEjecutor);
Console.WriteLine($"Saldo del ejecutor antes: {saldoEjecutorAntes}");

// Preparar la llamada de reclamación
var datosDeLlamadaDeReclamacion = contratoERC20.CreateCallData(
    "claim",
    new object[]
    {
        direccionBilleteraEjecutor, // receptor
        100, // cantidad
        Constants.NATIVE_TOKEN_ADDRESS, // moneda
        0, // precioPorToken
        new object[] { Array.Empty<byte>(), BigInteger.Zero, BigInteger.Zero, Constants.ADDRESS_ZERO }, // pruebaDeListaPermitida
        Array.Empty<byte>() // datos
    }
);

// Incluir la llamada de reclamación en la llamada de ejecución
var datosDeLlamadaDeEjecucion = contratoDelegacion.CreateCallData(
    method: "execute",
    parameters: new object[]
    {
        new List<Thirdweb.Console.Call>
        {
            new()
            {
                Data = datosDeLlamadaDeReclamacion.HexToBytes(),
                To = direccionContratoERC20,
                Value = BigInteger.Zero
            }
        }
    }
);

// Ejecutar desde la billetera del ejecutor apuntando al EOA que está apuntando al contrato de delegación
var tx2 = await ThirdwebTransaction.Create(billeteraEjecutor, new ThirdwebTransactionInput(chainId: cadenaCon7702, to: direccionBilleteraEOA, data: datosDeLlamadaDeEjecucion));
var hash2 = (await ThirdwebTransaction.SendAndWaitForTransactionReceipt(tx2)).TransactionHash;
Console.WriteLine($"Hash de la transacción de reclamación de tokens: {hash2}");

// Registrar el saldo ERC20 del ejecutor después de la reclamación
var saldoEjecutorDespues = await contratoERC20.ERC20_BalanceOf(direccionBilleteraEjecutor);
Console.WriteLine($"Saldo del ejecutor después: {saldoEjecutorDespues}");
```

**Nota**: Por el momento, esto solo funciona en cadenas habilitadas para 7702, como [Odyssey](https://thirdweb.com/odyssey-911867), y la función solo ha sido integrada con `PrivateKeyWallet`.

import {
	Tabs,
	TabsList,
	TabsTrigger,
	TabsContent,
	DocImage,
	createMetadata,
} from "@doc";
import EWCustomAuth from "../images/customauth.png";
import EWCustomAuthdb from "../images/customauthdb.png";
import EWCustomAuthdb2 from "../images/customauthdb2.png";

export const metadata = createMetadata({
	image: {
		title: "Configurar Autenticación para Billetera In-App",
		icon: "wallets",
	},
	title: "Configurar Autenticación Billetera In-App | thirdweb",
	description:
		"Configura la autenticación con el estándar OIDC o una opción genérica que te permite usar tu propio servidor de autenticación",
});

# Configuración

Ofrecemos dos opciones para configurar billeteras In-App con autenticación personalizada, una basada en el estándar [OIDC (Open ID Connect)](https://openid.net/developers/how-connect-works/) y una opción genérica que te permite usar tu propio servidor de autenticación. También puedes usar ambas opciones juntas si es necesario.

## Autenticación compatible con OIDC

La configuración de autenticación OIDC es una buena opción si usas un proveedor de autenticación externo como `Auth0`, `firebase`, `cognito`, etc., que publica la JWK para comprobar la autenticidad del token.

Un sistema de autenticación OIDC tiene un par de claves pública-privada, donde la clave privada se usa para firmar los tokens de autenticación.

- La clave pública se carga en una URL pública en formato JWKS. La ubicación estándar es `https://{domain}.com/.well-known/jwks.json`
- Cuando un usuario inicia sesión, se genera un token JWT llamado idToken y se firma con la clave privada. La especificación OIDC proporciona una interfaz para los campos que se utilizan en este token.
- Este JWT luego se pasa a la billetera In-App para generar una billetera para el usuario.
- Verificaremos el JWT contra la clave pública para comprobar que el JWT fue firmado correctamente. Tras una verificación exitosa, procederemos a generar una billetera basada en el valor `sub` (identificador del usuario) del idToken.

Para configurar una autenticación compatible con OIDC, habilita la primera opción en la pestaña de configuración del panel de la billetera In-App

<DocImage src={EWCustomAuthdb} />

Se te pedirá que ingreses los siguientes valores

- La URL del archivo JWKS (clave pública): Esto se usa para verificar que el token fue firmado por ti.
- El valor `aud` del idToken: Esto se usa para verificar que thirdweb es el usuario previsto del token

### Verificar a un usuario mediante autenticación compatible con OIDC

<Tabs defaultValue="react">
<TabsList>
	<TabsTrigger value="react">React</TabsTrigger>
	<TabsTrigger value="typescript">TypeScript</TabsTrigger>
</TabsList>

<TabsContent value="react">

```typescript
import { inAppWallet } from "thirdweb/wallets";
import { useConnect } from "thirdweb/react";

const { connect } = useConnect();

const handlePostLogin = async (jwt: string) => {
	await connect(() => {
		const wallet = inAppWallet();
		wallet.connect({
			client,
			strategy: "jwt",
			jwt,
		});
		return wallet;
	});
};
```

</TabsContent>

<TabsContent value="typescript">

```typescript
import { inAppWallet } from "thirdweb/wallets";

const wallet = inAppWallet();

const account = await wallet.connect({
	client,
	strategy: "jwt",
	jwt,
});

// use the account to send transactions
```

</TabsContent>
</Tabs>

## Autenticación genérica

La autenticación genérica es una opción de nivel inferior que se puede usar cuando tienes tu propio servidor de autenticación para autenticar a los usuarios.

La autenticación genérica es buena para admitir otros métodos de autenticación que no soportamos hoy, como Discord, Twitter, Github, etc., o algo completamente personalizado.

Flujo de alto nivel y requisitos para la autenticación genérica a través de un endpoint:

- Cuando un usuario inicia sesión, puedes generar un identificador público que te permita identificar al usuario.
- Puedes pasar este identificador a la billetera In-App para generar una billetera para el usuario.
- Al verificar al usuario, llamaremos a un endpoint que proporcionas para verificar la identidad del usuario.
- Luego generaremos una billetera para el usuario si el payload proporcionado es válido.

<DocImage src={EWCustomAuth} />

Para usar autenticación genérica, habilita la segunda opción en la pestaña de configuración del panel de la billetera In-App

<DocImage src={EWCustomAuthdb2} />

Se te pedirá que ingreses un endpoint al que podamos acceder para verificar la identidad del usuario. Este endpoint debe aceptar una solicitud POST con un cuerpo JSON que contenga los siguientes campos:

- `payload`: Esto corresponderá al identificador público que se generó para tu usuario. Ten en cuenta que esto se pasa desde el lado del cliente a través del SDK. Consulta el ejemplo a continuación para ver cómo se usa.

El endpoint debe devolver un cuerpo JSON que contenga los siguientes campos:

- `userId`: Un uid para el usuario. Esto se usará para identificar al usuario en la billetera si no hay un correo electrónico presente.
- `email` (opcional): Si se proporciona, el usuario podrá acceder a la misma cuenta fuera de la plataforma para cosas como exportar la clave privada // usar con wallet connect, etc.
  - Nota: Si se proporcionan dos valores `userId` diferentes con el mismo correo electrónico, ambos valores `userId` podrán acceder a la misma billetera.
  - Por el contrario, si se proporciona el mismo `userId` con dos correos electrónicos diferentes en diferentes sesiones de inicio de sesión, el `userId` tendrá dos billeteras asociadas con él. Cada billetera estará vinculada a uno de los correos electrónicos.
- `exp` (opcional): Una fecha de expiración para la sesión de la billetera del usuario. Por defecto, una sesión dura 7 días.

También puedes pasar una lista de encabezados. Estos encabezados se enviarán con cada solicitud a tu endpoint de verificación. Puedes usarlos para autenticar la solicitud.

### Verificar a un usuario mediante autenticación genérica

Una vez que hayas iniciado sesión con tu propia autenticación, puedes pasar el JWT del usuario a la billetera In-App para autenticar y conectar.

<Tabs defaultValue="react">
<TabsList>
	<TabsTrigger value="react">React</TabsTrigger>
	<TabsTrigger value="typescript">TypeScript</TabsTrigger>
</TabsList>

<TabsContent value="react">

```typescript
import { inAppWallet } from "thirdweb/wallets";
import { useConnect } from "thirdweb/react";

const { connect } = useConnect();

const handlePostLogin = async (jwt: string) => {
	await connect(() => {
		const wallet = inAppWallet();
		await wallet.connect({
			client,
			strategy: "auth_endpoint",
			// Este es el payload que se envía al endpoint de autenticación
			payload,
		});
		return wallet;
	});
};
```

</TabsContent>

<TabsContent value="typescript">

In other frameworks, use your own instance of the wallet to authenticate and connect.

```typescript
import { inAppWallet } from "thirdweb/wallets";

const wallet = inAppWallet();

const account = await wallet.connect({
	client,
	strategy: "auth_endpoint",
	// Este es el payload que se envía al endpoint de autenticación
	payload,
});

// use the account to send transactions
```

</TabsContent>
</Tabs>

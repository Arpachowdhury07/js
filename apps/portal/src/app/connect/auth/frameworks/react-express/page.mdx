import {
	OpenSourceCard,
	ArticleIconCard,
	Callout,
	Stack,
	createMetadata,
	InstallTabs,
	Tabs,
	TabsList,
	TabsContent,
	TabsTrigger,
} from "@doc";
import { GraduationCap } from "lucide-react";
import { V4SDKbanner } from "@/components/others/V4SDKBanner";

export const metadata = createMetadata({
	image: {
		title: "Integrate thirdweb Auth with Next.js",
		icon: "react",
	},
	title: "Auth in Next.js with thirdweb SDK",
	description: "Add support for Auth to your Next apps",
});

# React + Express

Si deseas interactuar con una versión funcional de la integración Auth + React que estaremos construyendo en esta guía, puedes consultar el siguiente repositorio de GitHub o clonarlo con el comando a continuación:

```
npx thirdweb create app --template thirdweb-auth-express
```

<OpenSourceCard
	title="thirdweb-auth-express"
	href="https://github.com/thirdweb-example/thirdweb-auth-express"
	description="React + Express Auth example repository."
/>

## Instalación y Configuración

<InstallTabs
	npm="npm i thirdweb"
	yarn="yarn add thirdweb"
	pnpm="pnpm i thirdweb"
	bun="bun i thirdweb"
/>

Crea un directorio para alojar tu cliente y servidor:

```shell
$ mkdir my-app
$ cd my-app
```

## Client-side Setup

### Configura Tu Aplicación

Crea una nueva aplicación React con Vite:


```shell
$ npm create vite@latest client -- --template react-ts
$ cd client
```

Configura el archivo `.env` de tu _aplicación React_ con lo siguiente:

```bash
# Get your client id from the thirdweb dashboard: https://thirdweb.com/create-api-key
THIRDWEB_CLIENT_ID=
# The url of your backend (Express) server for the frontend to interact with
AUTH_API=
```

Envuelve la raíz de tu aplicación con un proveedor de thirdweb:

```tsx
// main.tsx
ReactDOM.createRoot(document.getElementById("root")!).render(
	<React.StrictMode>
		<ThirdwebProvider>// Your application layout...</ThirdwebProvider>
	</React.StrictMode>,
);
```

### Creación de un Cliente

Crea y exporta un cliente de thirdweb en algún lugar de tu aplicación para que sea utilizado en tus componentes. Este cliente te da acceso a las RPCs de thirdweb para leer y escribir en la blockchain.

```tsx
// lib/client.ts
import { createThirdwebClient } from "thirdweb";

const clientId = process.env.THIRDWEB_CLIENT_ID!;

export const client = createThirdwebClient({ clientId });
```

<Callout variant="info">
	¿No tienes una clave secreta? Consigue una [aquí](https://thirdweb.com/create-api-key).
</Callout>


### Añadiendo el Botón de Conexión

Crea tu componente `<ConnectButton />`. **Aquí es donde tus usuarios iniciarán sesión.**

```tsx
// components/ConnectButtonAuth.tsx
import { ConnectButton } from "thirdweb/react";
import { client } from "../lib/client";
import { LoginPayload, VerifyLoginPayloadParams } from "thirdweb/auth";
import { get, post } from "../lib/api";
import { sepolia } from "thirdweb/chains";

export default function ConnectButtonAuth() {
	return (
		<ConnectButton
			client={client}
			auth={{
				/**
				 * 	`getLoginPayload` should @return {VerifyLoginPayloadParams} object.
				 * 	This can be generated on the server with the generatePayload method.
				 */
				getLoginPayload: async (params: {
					address: string;
				}): Promise<LoginPayload> => {
					return get({
						url: process.env.AUTH_API + "/login",
						params: {
							address: params.address,
							chainId: sepolia.id.toString(),
						},
					});
				},
				/**
				 * 	`doLogin` performs any logic necessary to log the user in using the signed payload.
				 * 	In this case, this means sending the payload to the server for it to set a JWT cookie for the user.
				 */
				doLogin: async (params: VerifyLoginPayloadParams) => {
					await post({
						url: process.env.AUTH_API + "/login",
						params,
					});
				},
				/**
				 * 	`isLoggedIn` returns true or false to signal if the user is logged in.
				 * 	Here, this is done by calling the server to check if the user has a valid JWT cookie set.
				 */
				isLoggedIn: async () => {
					return await get({
						url: process.env.AUTH_API + "/isLoggedIn",
					});
				},
				/**
				 * 	`doLogout` performs any logic necessary to log the user out.
				 * 	In this case, this means sending a request to the server to clear the JWT cookie.
				 */
				doLogout: async () => {
					await post({
						url: process.env.AUTH_API + "/logout",
					});
				},
			}}
		/>
	);
}
```

### Añadiendo Abstracción de Cuentas

Para proporcionar a tus usuarios una billetera inteligente y permitir que tu aplicación patrocine el gas y agrupe transacciones, agrega lo siguiente a tu `<ConnectButton />`:

```tsx
<ConnectButton
	// ...
	accountAbstraction={{
		chain: sepolia, // Update this to your chain of choice
		factoryAddress: "0x5cA3b8E5B82D826aF6E8e9BA9E4E8f95cbC177F4", // Set this to your Account Factory. You can deploy one from Team > Project > Connect > Account Abstraction page
		gasless: true, // Sponsor gas for your users
	}}
/>
```

## Server-side Setup

### Configura Tu API de Express

Crea un nuevo directorio para tu servidor backend:

```shell
$ mkdir server
$ cd server
```

Inicializa un nuevo proyecto de Node:

```shell
$ npm init
```

Acepta los valores predeterminados por ahora. Una vez que tu proyecto esté inicializado, instala las dependencias:

```shell
$ npm install express cors cookie-parser thirdweb
```

Crea un archivo `.env` con lo siguiente:

```bash
# Obtén tu ID de cliente desde el panel de thirdweb: https://thirdweb.com/create-api-key
THIRDWEB_SECRET_KEY=
# El dominio de tu frontend -- incluye el puerto cuando trabajes localmente, pero nada más (recuerda actualizar esto en producción)
CLIENT_DOMAIN=localhost:5173
# Una clave privada de billetera para generar el JWT
AUTH_PRIVATE_KEY=
NODE_ENV=development # ¡Cámbialo a production cuando lo despliegues!
```

<Callout variant="info">
	Para simplificar las cosas, hemos colocado todas las rutas del lado del servidor en el mismo archivo. 
	Para una aplicación de nivel de producción, probablemente las dividirás dependiendo de lo que funcione mejor para tu caso de uso. 
	De cualquier manera, la lógica central es la misma que ves aquí.
</Callout>


### Crea un Cliente del Lado del Servidor

Crea un cliente del lado del servidor utilizando tu clave secreta:


```ts
// thirdwebClient.js
import { createThirdwebClient } from "thirdweb";

const secretKey = process.env.THIRDWEB_SECRET_KEY!;

export const thirdwebClient = createThirdwebClient({ secretKey });
```

### Configura tu Servidor de Express

Asumiremos que ya configuraste una API básica de Express, pero hay algunas cosas que debes asegurarte de haber hecho para que la autenticación funcione correctamente entre tu frontend y backend.

```js
import cors from "cors";
import express from "express";
import cookieParser from "cookie-parser";
import { createAuth, type VerifyLoginPayloadParams } from "thirdweb/auth";
import { privateKeyToAccount } from "thirdweb/wallets";
import { thirdwebClient } from "./thirdwebClient";

const app = express();
app.use(express.json());
app.use(cookieParser());
app.use(
	// This is important for the cookie to be saved properly!!!
	cors({
		origin: `${process.env.NODE_ENV === "development" ? "http" : "https"}://${process.env.CLIENT_DOMAIN}`,
		credentials: true,
	}),
);

// ...we'll add routes here next

app.listen(3000, () => {
	console.log(`⚡ Auth server listening on port 3000...`);
});
```

Crea tu instancia de autenticación de thirdweb

```js
const thirdwebAuth = createAuth({
	domain: process.env.CLIENT_DOMAIN!,
	client: thirdwebClient,
	adminAccount: privateKeyToAccount({
		client: thirdwebClient,
		privateKey: process.env.ADMIN_PRIVATE_KEY!,
	}),
});
```

Configura una ruta `GET` en `/login` para obtener el payload de inicio de sesión:

```js
app.get("/login", async (req, res) => {
	const address = req.query.address;
	const chainId = req.query.chainId;

	if (!address) {
		return res.status(400).send("Address is required");
	}

	return res.send(
		await thirdwebAuth.generatePayload({
			address,
			chainId: chainId ? parseInt(chainId) : undefined,
		}),
	);
});
```

Aquí obtenemos la dirección del usuario y el ID de la cadena para generar el payload utilizando thirdweb Auth. Este payload será devuelto al cliente para que el usuario lo firme con su billetera. Luego, será enviado de vuelta al servidor para su verificación.

Crea una ruta `POST` también en `/login` para que el frontend envíe el payload firmado:


```js
app.post("/login", async (req, res) => {
	const payload: VerifyLoginPayloadParams = req.body;

	const verifiedPayload = await thirdwebAuth.verifyPayload(payload);

	if (verifiedPayload.valid) {
		const jwt = await thirdwebAuth.generateJWT({
			payload: verifiedPayload.payload,
		});
		res.cookie("jwt", jwt);
		return res.status(200).send({ token: jwt });
	}

	res.status(400).send("Failed to login");
});
```

Recibimos el payload firmado, lo verificamos a través de thirdweb Auth y luego creamos un JWT si el payload firmado es válido. Este JWT se asigna a este dominio y permite que el cliente se identifique como autenticado ante el servidor para futuras solicitudes (hasta que el token expire).

Ahora, creamos una ruta para verificar si el usuario está actualmente autenticado:


```js
app.get("/isLoggedIn", async (req, res) => {
	const jwt = req.cookies?.jwt;

	if (!jwt) {
		return res.send(false);
	}

	const authResult = await thirdwebAuth.verifyJWT({ jwt });

	if (!authResult.valid) {
		return res.send(false);
	}

	return res.send(true);
});
```

Si el usuario no tiene un token, definitivamente no ha iniciado sesión, por lo que inmediatamente devolvemos `false`. Si tiene un token, lo verificamos para asegurarnos de que sea tanto válido como no esté expirado. Si ambos son verdaderos, devolvemos `true`.

Finalmente, necesitamos una ruta para cerrar la sesión del usuario eliminando su token:

```js
app.post("/logout", (req, res) => {
	res.clearCookie("jwt");
	return res.send(true);
});
```

Para cualquier ruta que agregues a tu servidor, puedes autenticar al usuario tal como lo hicimos en `/isLoggedIn`:

```js
app.get("/secure", async (req, res) => {
	const jwt = req.cookies?.jwt;

	if (!jwt) {
		return res.status(401).send("Unauthorized");
	}

	const authResult = await thirdwebAuth.verifyJWT({ jwt });

	if (!authResult.valid) {
		return res.status(401).send("Unauthorized");
	}

	// ...your route logic
});
```

Recuerda que tu `app.listen` (cuando inicias el servidor) debe estar **después** de tus rutas.

¡Eso es todo! Ahora tienes una aplicación React + Express completamente configurada con SIWE. Al ejecutar tu aplicación, asegúrate de iniciar tanto el cliente como el servidor.

## Soporte

Para ayuda o comentarios, por favor [visita nuestro sitio de soporte](https://thirdweb.com/support)


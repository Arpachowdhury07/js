import { Callout } from "@doc";

# Preparar Transacciones

Todas las transacciones enviadas con el SDK deben ser preparadas primero. Preparar una transacción es sincrónico, liviano y no requiere solicitudes de red. También te proporciona definiciones seguras en cuanto a tipos para tus llamadas al contrato.

## Preparar una llamada al contrato

La forma recomendada de preparar una llamada al contrato es pasar la firma del método Solidity y los parámetros. Esto es seguro en cuanto a tipos, basado en la firma del método Solidity que defines. Puedes obtener la firma del método del contrato que desees directamente desde el código Solidity.

```ts
import { prepareContractCall, toWei } from "thirdweb";

const tx = prepareContractCall({
	contract,
	// Pass the method signature that you want to call
	method: "function mintTo(address to, uint256 amount)",
	// and the params for that method
	// Their types are automatically inferred based on the method signature
	params: ["0x123...", toWei("100")],
});
```

Esto devolverá un objeto de transacción preparada que está listo para ser enviado a la blockchain y puede ser procesado de diversas maneras.

## Preparar una transacción en bruto

También puedes crear una transacción en bruto directamente. Esto es útil cuando deseas enviar ether a una dirección, por ejemplo, o cuando ya tienes datos codificados.

```ts
import { prepareTransaction, toWei } from "thirdweb";

const transaction = prepareTransaction({
	// The account that will be the receiver
	to: "0x456...",
	// The value is the amount of ether you want to send with the transaction
	value: toWei("1"),
	// The chain to execute the transaction on
	chain: defineChain(1),
	// Your thirdweb client
	client,
});
```

## Otras formas de preparar una transacción

Existen algunas otras formas de preparar una llamada al contrato, todas ellas devuelven el mismo objeto de transacción.

### Generar funciones de extensión para un contrato desplegado

Usando la CLI, puedes generar funciones optimizadas para todas las llamadas posibles a un contrato. Esto te ahorra tiempo y precomputará toda la codificación necesaria.

```shell
npx thirdweb generate <contractId>/<contractAddress>
```

Lee más sobre cómo [generar funciones de extensión usando la CLI](/cli).

### ABI explícito del contrato

Otra forma de obtener seguridad en cuanto a tipos es pasar el ABI completo del contrato a `getContract`. Esto te proporcionará autocompletado para todos los métodos declarados en el ABI. Hay un pequeño costo de extracción por tener el ABI completo en tu código, lo cual puede ser bastante grande.

```ts
import { getContract, prepareContractCall, toWei } from "thirdweb";

const contract = getContract({
  client,
	chainId,
  // The ABI for the contract is defined here
  abi: [
    ...
    {
      name: "mintTo",
      inputs: [
        {
          type: "address",
          name: "to",
        },
        {
          type: "uint256",
          name: "amount",
        },
      ],
      type: "function",
    }
    ...
  ],
});

const tx = prepareContractCall({
  contract,
  // We get auto-completion for all the available functions on the contract ABI
  method: "mintTo",
  // including full type-safety for the params
  params: ["0x123...", toWei("100")],
});
```

### Fragmento de ABI

Como alternativa a pasar el ABI completo, puedes pasar un fragmento del ABI para el método que deseas llamar. Esto es útil cuando solo deseas llamar a un solo método y no quieres tener el ABI completo en tu código.

```ts
import { prepareContractCall, toWei } from "thirdweb";

const tx = prepareContractCall({
	contract,
	// Pass a snippet of the ABI for the method you want to call.
	method: {
		name: "mintTo",
		inputs: [
			{
				type: "address",
				name: "to",
			},
			{
				type: "uint256",
				name: "amount",
			},
		],
		type: "function",
	},
	// The Types of `params` are automatically inferred based on the ABI inputs.
	params: ["0x123...", toWei("100")],
});
```

### Resolución automática de ABI

Finalmente, puedes resolver dinámicamente los métodos del contrato en tiempo de ejecución utilizando la función `resolveMethod`. Esta es la mejor manera de manejar contratos cuyo ABI no conoces de antemano, pero también es menos eficiente y no es segura en cuanto a tipos.

```ts
import { prepareContractCall, resolveMethod, toWei } from "thirdweb";
const tx = prepareContractCall({
	contract,
	// in this case we only pass the name of the method we want to call
	method: resolveMethod("mintTo"),
	// however using this method we lose type safety for our params
	params: ["0x123...", toWei("100")],
});
```

<Callout title="Por favor ten en cuenta" variant="info">

Este método es conveniente, sin embargo, también es:

- menos eficiente en tiempo de ejecución (tiene que resolver el ABI del contrato y luego hacer coincidir el nombre del método que proporcionas)
- no es seguro en cuanto a tipos (pierdes la seguridad de tipos para tus parámetros)

Existen casos en los que específicamente _necesitas_ poder resolver métodos dinámicamente en tiempo de ejecución, en cuyo caso este método es útil.

</Callout>


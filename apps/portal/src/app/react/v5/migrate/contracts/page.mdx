[Migrate from React v4](/react/v5/migrate)

# Interactuar con contratos

Con el SDK v4, siempre tienes que "cargar" un contrato con `useContract`. Este proceso añade complejidad a tu aplicación e impacta su rendimiento.  
En la versión más reciente, un contrato inteligente (tipo: [`ThirdwebContract`](/references/typescript/v5/ThirdwebContract)) representa un objeto simple que contiene información sobre la dirección del contrato, la cadena en la que fue desplegado y el objeto del cliente de thirdweb.

Ejemplo de cómo declarar un contrato inteligente en la red principal de Ethereum:

```tsx
import { getContract, createThirdwebClient } from "thirdweb";
import { ethereum } from "thirdweb/chains";

const client = createThirdwebClient({
  clientId: process.env.NEXT_PUBLIC_TW_CLIENT_ID,
});

const contract = getContract({
  address: "0x....",
  chain: ethereum,
  client,
});
```

## Extensiones de Contrato

Esta es una nueva terminología que introdujimos en el nuevo SDK. Básicamente, cada extensión representa un método de un contrato, ya sea un método de "escritura" o de "lectura".

Una extensión es una función que devuelve una [`PreparedTransaction`](/references/typescript/v5/PreparedTransaction), la cual a su vez puede ser ejecutada en un hook de React para interactuar con el contrato. Hablaremos más sobre esto en la sección siguiente.

Una de las increíbles actualizaciones que trae v5 es el conjunto de extensiones preconstruidas. Son los métodos del contrato que han sido precompilados para asegurar una experiencia de desarrollo segura en cuanto a tipos y de alto rendimiento.

Consulta la lista de más de 100 extensiones preconstruidas [aquí](/typescript/v5/extensions/built-in), que van desde ERC20, ERC721, ERC1155 hasta populares protocolos DeFi como Uniswap, Farcaster y Lens.

Ejemplo: Importar una extensión "de lectura" de ERC1155, para consultar el saldo de una billetera

```tsx
import { balanceOf } from "thirdweb/extension/erc1155";

const transaction = balanceOf({
  contract,
  owner: "0x...",
  tokenId: 0n,
});
```

## Leer los estados de un contrato
Dado el objetivo de llamar a `balanceOf` desde un contrato ERC1155, compararemos el código entre v4 y v5.

#### SDK v4
```tsx
import { useNFTBalance, useContract } from "@thirdweb-dev/react";

function App() {
  const { contract } = useContract(contractAddress);
  const { isLoading, data, error } = useNFTBalance(
    contract,
    "{{wallet_address}}",
    "{{token_id}}",
  );
}

```

#### SDK v5
```tsx
import { getContract, createThirdwebClient } from "thirdweb";
import { balanceOf } from "thirdweb/extensions/erc1155";
import { ethereum } from "thirdweb/chains";
import { client } from "@lib/client";

const contract = getContract({
  address: "0x....",
  chain: ethereum,
  client,
});

function App() {
  const { data } = useReadContract(balanceOf, { contract, owner: "0x...", tokenId: 0n });
}
```

Como puedes ver en el ejemplo anterior, introdujimos el hook [`useReadContract`](/references/typescript/v5/useReadContract) en v5.  
Debes usarlo para realizar cualquier "lectura" de contrato en tu aplicación React.  
Es el reemplazo perfecto para los antiguos hooks pesados de React de v4.

La fórmula para leer el estado de un contrato es:

```
useReadContract + <the read contract method>
```

#### Si la extensión que buscas no está incluida en el SDK
Siempre puedes usar la firma de la función con `useReadContract` (también es segura en cuanto a tipos)
```tsx
useReadContract({
  contract,
  method: "function balanceOf(address _owner, uint256 tokenId) view returns (uint256)",
  ...
})

```

#### Un consejo para obtener la firma de una función
Ve a la página del explorador en el Dashboard de thirdweb y selecciona la función con la que deseas interactuar.  
Deberías ver la sección "Usa esta función en tu aplicación" con el fragmento de código para la firma de la función.

[Un ejemplo](https://thirdweb.com/avalanche-fuji/0xd5e815241882676F772A624E3892b27Ff3a449c4/explorer?name=balanceOf)


## Escribir en un contrato
En v5, puedes utilizar los siguientes hooks para escribir en contratos: [`useSendTransaction`](/references/typescript/v5/useSendTransaction) y [`useSendAndConfirmTransaction`](/references/typescript/v5/useSendAndConfirmTransaction).  
La principal diferencia entre los 2 hooks es que `useSendTransaction` marcará la solicitud como "completa" una vez que la transacción se haya enviado,  
mientras que `useSendAndConfirmTransaction` esperará hasta que la transacción esté incluida en la blockchain.

Dado el objetivo de reclamar un NFT de una colección de NFT Drop, comparemos el código entre el SDK v4 y v5.

#### SDK V4
```tsx
import { useContract, useClaimNFT } from "@thirdweb-dev/react";

function App() {
  const { contract } = useContract(contractAddress);
  const {
    mutateAsync: claimNft,
    isLoading,
    error,
  } = useClaimNFT(contract);

  return (
    <Web3Button
      contractAddress={contractAddress}
      action={() =>
        claimNft({
          to: "{{wallet_address}}", // Usa el hook useAddress para obtener la dirección actual de la billetera
          quantity: 1,
        })
      }
    >
      Claim NFT
    </Web3Button>
  );
}
```

#### SDK v5
```tsx
import { useSendTransaction } from "thirdweb/react";
import { claimTo } from "thirdweb/extension/erc721";

function App() {
  const transaction = claimTo({ contract, quantity: 1n, to: "0x..." });
  const { mutateAsync: claimNft } = useSendTransaction();

  return <button onClick={() => claimNft(transaction)}>
    Claim
  </button>
}
```

Otra cosa maravillosa del SDK v5 es que viene con el [`TransactionButton`](/references/typescript/v5/TransactionButton),  
el cual te permite hacer una llamada a un contrato _sin_ tener que usar los hooks de React mencionados anteriormente. ¡Como puedes ver, el código es mucho más limpio de esta manera!

```tsx
import { TransactionButton } from "thirdweb/react";
import { claimTo } from "thirdweb/extension/erc721";

function App() {
  return <TransactionButton transaction={
    () => claimTo({ contract, quantity: 1n, to: "0x..." })
  }>
    Claim
  </TransactionButton>
}
```
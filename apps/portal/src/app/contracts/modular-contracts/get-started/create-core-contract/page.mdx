import { createMetadata, Steps, Step } from "@doc";

export const metadata = createMetadata({
	title: "thirdweb Modular Contracts",
	description:
		"Modular Contract provides a framework to build custom smart contracts more efficiently by offering a set of pre-built base contracts and reusable components, better known as modules.",
	image: {
		title: "thirdweb Modular Contracts",
		icon: "solidity",
	},
});

# Crear un Contrato Base

### Instalación

Instala Forge desde Foundry y agrega el marco de contratos modulares:

```bash
forge init
forge install thirdweb-dev/modular-contracts --no-commit
```

Agrega los contratos modulares de Thirdweb a `foundry.toml` bajo `remappings`:

```toml
remappings = ['@thirdweb-dev=lib/modular-contracts/']
```

### Configurar el Contrato Principal

<Steps>

<Step title="Crear un Contrato Principal">
   Crea un nuevo archivo en la carpeta `src` llamado `CounterCore.sol`, e hereda el contrato `Core`.

```solidity
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.20;

 import {Core} from "@thirdweb-dev/src/Core.sol";
 import {BeforeIncrementCallback} from "./interface/BeforeIncrementCallback.sol";

 contract CounterCore is Core {
     constructor(address owner) {
         _initializeOwner(owner);
     }
 }

```

> **Nota**
> El contrato `Core` es el contrato base que debe ser heredado para que este contrato sea reconocido como un contrato principal.

</Step>

<Step title="Configurar la Función getSupportedCallbackFunctions">
Implementa la función `getSupportedCallbackFunctions`. El contrato `Core` es abstracto porque esta función no está implementada. Para evitar errores de compilación, declara la función con un cuerpo vacío por ahora.

    ```solidity
        // SPDX-License-Identifier: MIT
        pragma solidity ^0.8.20;

        import {Core} from "@thirdweb-dev/src/Core.sol";

        contract CounterCore is Core {
            constructor(address owner) {
                _initializeOwner(owner);
            }

            function getSupportedCallbackFunctions()
                public
                pure
                override
                returns (SupportedCallbackFunction[] memory supportedCallbackFunctions)
            {}
        }
    ```

</Step>

<Step title="Configurar la función de incremento">
   Define una función para incrementar un contador.


```solidity
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.20;

 import {Core} from "@thirdweb-dev/src/Core.sol";

 contract CounterCore is Core {
     uint256 public count;

     constructor(address owner) {
         _initializeOwner(owner);
     }

     function getSupportedCallbackFunctions()
         public
         pure
         override
         returns (SupportedCallbackFunction[] memory supportedCallbackFunctions)
     {}

     // 👇👇👇👇👇👇👇👇👇
     function increment() public {
         count += 1;
     }
 }
```

</Step>

<Step title="Agregar una función de devolución de llamada">
   Introduce la función `_beforeIncrement` para utilizar el callback `beforeIncrement` de un módulo. Para lograr esto, introduciremos la interfaz `BeforeIncrementCallback`.

> **Nota**
> Las funciones de devolución de llamada son funcionalidades similares a los hooks que se pueden usar antes o después de la funcionalidad principal de un contrato base.
> En este ejemplo, el callback `beforeIncrement` se ejecuta antes de la funcionalidad principal de incremento.

```solidity
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.20;

 import {Core} from "@thirdweb-dev/src/Core.sol";

 // 👇👇👇👇👇👇👇👇👇

 interface BeforeIncrementCallback {
     function beforeIncrement(uint256 count) external returns (uint256);
 }

 contract CounterCore is Core {
     uint256 public count;

     constructor(address owner) {
         _initializeOwner(owner);
     }

     function getSupportedCallbackFunctions()
         public
         pure
         override
         returns (SupportedCallbackFunction[] memory supportedCallbackFunctions)
     {}

     function increment() public {
         count += 1;
     }

     // 👇👇👇👇👇👇👇👇👇

     function _beforeIncrement(
         uint256 _count
     ) internal returns (uint256 newCount) {
         (, bytes memory returnData) = _executeCallbackFunction(
             BeforeIncrementCallback.beforeIncrement.selector,
             abi.encodeCall(BeforeIncrementCallback.beforeIncrement, (_count))
         );

         newCount = abi.decode(returnData, (uint256));
     }
 }

```

</Step>

<Step title="Implementar funciones compatibles">
   Implementa las funciones `getSupportedCallbackFunctions` y `supportsInterface` para exponer qué funciones de devolución de llamada e interfaces soporta este contrato base.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import {Core} from "@thirdweb-dev/src/Core.sol";

interface BeforeIncrementCallback {
    function beforeIncrement(uint256 count) external returns (uint256);
}

contract CounterCore is Core {
    uint256 public count;

    constructor(address owner) {
        _initializeOwner(owner);
    }

     // 👇👇👇👇👇👇👇👇👇
    function getSupportedCallbackFunctions()
        public
        pure
        override
        returns (SupportedCallbackFunction[] memory supportedCallbackFunctions)
    {
        supportedCallbackFunctions = new SupportedCallbackFunction[](1);
        supportedCallbackFunctions[0] = SupportedCallbackFunction({
            selector: BeforeIncrementCallback.beforeIncrement.selector,
            mode: CallbackMode.OPTIONAL
        });
    }

    function increment() public {
        count += 1;
    }

    function _beforeIncrement(
        uint256 _count
    ) internal returns (uint256 newCount) {
        (, bytes memory returnData) = _executeCallbackFunction(
            BeforeIncrementCallback.beforeIncrement.selector,
            abi.encodeCall(BeforeIncrementCallback.beforeIncrement, (_count))
        );

        newCount = abi.decode(returnData, (uint256));
    }

     // 👇👇👇👇👇👇👇👇👇
    function supportsInterface(
        bytes4 interfaceId
    ) public view override returns (bool) {
        return interfaceId == 0x00000001 || super.supportsInterface(interfaceId);
    }
}

```

</Step>

</Steps>

---

Esta guía te ayudará a crear un contrato base que pueda incrementar un contador con funciones de devolución de llamada opcionales para añadir funcionalidades modulares adicionales.

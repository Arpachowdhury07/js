import { createMetadata, Steps, Step } from "@doc";

export const metadata = createMetadata({
	title: "thirdweb Modular Contracts",
	description:
		"Modular Contract provides a framework to build custom smart contracts more efficiently by offering a set of pre-built base contracts and reusable components, better known as modules.",
	image: {
		title: "thirdweb Modular Contracts",
		icon: "solidity",
	},
});

# Crear Contrato de Módulo
**Requisito previo:** Lee “Crear Contrato Principal” antes de crear un Módulo.

### Instalación

<Steps>

<Step title="Instalar Forge desde Foundry">
   Para obtener ayuda, consulta la [guía de instalación de Foundry](https://book.getfoundry.sh/getting-started/installation).

```bash
forge init
forge install thirdweb-dev/modular-contracts --no-commit
```

Añadir los contratos modulares de Thirdweb a `foundry.toml` bajo `remappings`:

```toml
remappings = ['@thirdweb-dev=lib/modular-contracts/']
```

</Step>

### Crear Módulo

<Step title="Crear un Nuevo Archivo de Módulo">
   Crea un nuevo archivo llamado `CounterModule.sol` en la carpeta `src` y comienza con el siguiente código:

```solidity
//SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {Module} from "@thirdweb-dev/src/Module.sol";

contract CounterModule is Module {
    function getModuleConfig()
        public
        pure
        override
        returns (ModuleConfig memory config)
    {}
}
```

> **Note:**
> El contrato `Module` es el contrato base que debe ser heredado para que este contrato sea reconocido como un Contrato de Módulo, y necesitamos implementar la función `getModuleConfig` para evitar que el contrato sea marcado como abstracto.

</Step>

<Step title="Crear una Librería de Almacenamiento">
   Crea una librería llamada `CounterStorage` responsable de mantener el estado del Contrato de Módulo:

```solidity
//SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {Module} from "@thirdweb-dev/src/Module.sol";

contract CounterModule is Module {
    function getModuleConfig()
        public
        pure
        override
        returns (ModuleConfig memory config)
    {}
}

 // 👇👇👇👇👇👇👇👇👇
library CounterStorage {
    /// @custom:storage-location erc7201:token.minting.counter
    bytes32 public constant COUNTER_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("counter")) - 1)) &
            ~bytes32(uint256(0xff));

    struct Data {
        uint256 step;
    }

    function data() internal pure returns (Data storage data_) {
        bytes32 position = COUNTER_STORAGE_POSITION;
        assembly {
            data_.slot := position
        }
    }
}

```

> **Nota:**
> La librería `CounterStorage` utiliza el diseño de almacenamiento de espacio de nombres ERC-7201 para almacenar los datos. Aprende más sobre [ERC-7201](https://eips.ethereum.org/EIPS/eip-7201).

</Step>

<Step title="Configurar Función de Acceso a Almacenamiento">
   Configura la función `_counterStorage` para acceder al almacenamiento desde la librería `CounterStorage`:

```solidity
//SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {Module} from "@thirdweb-dev/src/Module.sol";

contract CounterModule is Module {
    function getModuleConfig()
        public
        pure
        override
        returns (ModuleConfig memory config)
    {}

     // 👇👇👇👇👇👇👇👇👇

    function _counterStorage()
        internal
        pure
        returns (CounterStorage.Data storage)
    {
        return CounterStorage.data();
    }
}

library CounterStorage {
    /// @custom:storage-location erc7201:token.minting.counter
    bytes32 public constant COUNTER_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("counter")) - 1)) &
            ~bytes32(uint256(0xff));

    struct Data {
        uint256 step;
    }

    fun2ction data() internal pure returns (Data storage data_) {
        bytes32 position = COUNTER_STORAGE_POSITION;
        assembly {
            data_.slot := position
        }
    }
}

```

</Step>

<Step title="Configurar Funciones de Fallback">
   Configura funciones de fallback que actúan como los setters y getters para `step`:

```solidity
//SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {Module} from "@thirdweb-dev/src/Module.sol";

contract CounterModule is Module {
    function getModuleConfig()
        public
        pure
        override
        returns (ModuleConfig memory config)
    {}

    function _counterStorage()
        internal
        pure
        returns (CounterStorage.Data storage)
    {
        return CounterStorage.data();
    }

    // 👇👇👇👇👇👇👇👇👇
    // Fallback Functions
    function getStep() external view returns (uint256) {
        return _counterStorage().step;
    }

    function setStep(uint256 _step) external {
        _counterStorage().step = _step;
    }
}

library CounterStorage {
    /// @custom:storage-location erc7201:token.minting.counter
    bytes32 public constant COUNTER_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("counter")) - 1)) &
            ~bytes32(uint256(0xff));

    struct Data {
        uint256 step;
    }

    function data() internal pure returns (Data storage data_) {
        bytes32 position = COUNTER_STORAGE_POSITION;
        assembly {
            data_.slot := position
        }
    }
}

```

> **Note:**
> Las funciones de fallback son funcionalidades adicionales que un contrato central puede usar a través de la función `fallback` de Solidity.

</Step>

<Step title="Configurar la Función de Callback">
   Configura una función de callback `beforeIncrement` que aumente el contador dado por `step`:

```solidity
//SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {Module} from "@thirdweb-dev/src/Module.sol";

contract CounterModule is Module {
    function getModuleConfig()
        public
        pure
        override
        returns (ModuleConfig memory config)
    {}

    function _counterStorage()
        internal
        pure
        returns (CounterStorage.Data storage)
    {
        return CounterStorage.data();
    }

    // Fallback Functions
    function getStep() external view returns (uint256) {
        return _counterStorage().step;
    }

    function setStep(uint256 _step) external {
        _counterStorage().step = _step;
    }


    // 👇👇👇👇👇👇👇👇👇
    function beforeIncrement(uint256 count) external view returns (uint256) {
        return count + _counterStorage().step;
    }
}

library CounterStorage {
    /// @custom:storage-location erc7201:token.minting.counter
    bytes32 public constant COUNTER_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("counter")) - 1)) &
            ~bytes32(uint256(0xff));

    struct Data {
        uint256 step;
    }

    function data() internal pure returns (Data storage data_) {
        bytes32 position = COUNTER_STORAGE_POSITION;
        assembly {
            data_.slot := position
        }
    }
}

```

> **Note:**
> Las funciones de callback son funcionalidades tipo hook que se pueden usar antes o después de la funcionalidad principal de un contrato central. En este fragmento, el callback `beforeIncrement` se utiliza antes de la funcionalidad principal de incremento.

</Step>

<Step title="Configurar el Módulo">
   Finalmente, configura la funcionalidad `getModuleConfig`, ya que esta es la encargada de comunicarse con el contrato central:

```solidity
//SPDX-License-Identifier: MIT

pragma solidity ^0.8.20;

import {Module} from "@thirdweb-dev/src/Module.sol";
// 👇👇👇👇👇👇👇👇👇
import {Role} from "@thirdweb-dev/src/Role.sol";

contract CounterModule is Module {
    // 👇👇👇👇👇👇👇👇👇
    function getModuleConfig()
        public
        pure
        override
        returns (ModuleConfig memory config)
    {
        // Callback Function array of one element
        config.callbackFunctions = new CallbackFunction[](1);
        // Fallback Function array of two elements
        config.fallbackFunctions = new FallbackFunction[](2);

        //adding the functions to the arrays
        config.callbackFunctions[0] = CallbackFunction(
            this.beforeIncrement.selector
        );

        config.fallbackFunctions[0] = FallbackFunction({
            selector: this.getStep.selector,
            permissionBits: 0
        });

        config.fallbackFunctions[1] = FallbackFunction({
            selector: this.setStep.selector,
            permissionBits: Role._MANAGER_ROLE
        });

        // Required interfaces for the Module
        config.requiredInterfaces = new bytes4[](1);
        config.requiredInterfaces[0] = 0x00000001;

        // register the intallation callback
        config.registerInstallationCallback = true;
    }

    function _counterStorage()
        internal
        pure
        returns (CounterStorage.Data storage)
    {
        return CounterStorage.data();
    }

    // Fallback Functions
    function getStep() external view returns (uint256) {
        return _counterStorage().step;
    }

    function setStep(uint256 _step) external {
        _counterStorage().step = _step;
    }

    function beforeIncrement(uint256 count) external view returns (uint256) {
        return count + _counterStorage().step;
    }
}

library CounterStorage {
    /// @custom:storage-location erc7201:token.minting.counter
    bytes32 public constant COUNTER_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("counter")) - 1)) &
            ~bytes32(uint256(0xff));

    struct Data {
        uint256 step;
    }

    function data() internal pure returns (Data storage data_) {
        bytes32 position = COUNTER_STORAGE_POSITION;
        assembly {
            data_.slot := position
        }
    }
}

```

</Step>

</Steps>

---

En el siguiente tutorial, aprende cómo desplegar este contrato modular y adjuntarlo al contrato principal.
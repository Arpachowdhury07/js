import { createMetadata } from "@doc";

export const metadata = createMetadata({
	title: "thirdweb Modular Contracts",
	description:
		"Modular Contract provides a framework to build custom smart contracts more efficiently by offering a set of pre-built base contracts and reusable components, better known as modules.",
	image: {
		title: "thirdweb Modular Contracts",
		icon: "solidity",
	},
});

# ¿Cómo Funcionan los Contratos Modulares?

Los contratos modulares están compuestos por dos componentes principales:

1. **Contratos Base**
2. **Contratos de Módulos**

Los contratos base sirven como la base sobre la que se instalan los contratos de módulos. Los contratos de módulos son contratos inteligentes que proporcionan funcionalidad adicional y se pueden instalar o desinstalar de un contrato base. Puedes pensar en los contratos base y de módulos como piezas de construcción, como piezas de Lego.

#### ¿Cómo Proveen los Contratos de Módulos Funcionalidad Adicional?

Una vez instalados, los contratos de módulos proporcionan funcionalidad adicional mediante la creación de funciones `fallback` y `callback` con las que el contrato base puede interactuar a través de llamadas delegadas.

- **Funciones Fallback**: Son funciones independientes que pueden ser llamadas a través del contrato base.
- **Funciones Callback**: Son funciones dependientes que deben ser llamadas dentro del contexto de una función del contrato base. Estas funciones mejoran la funcionalidad del contrato base ejecutando lógica adicional antes o después de la lógica principal del contrato base.

#### ¿Cómo se Instalan los Contratos de Módulos en los Contratos Base?

Al igual que las piezas de Lego, los contratos modulares deben "encajar" correctamente. Si las piezas no se alinean—es decir, los contratos no son compatibles—no se pueden instalar juntos.

Esto plantea la pregunta:

#### ¿Qué Hace Que un Contrato de Módulo Sea Compatible con un Contrato Base?

Dos factores determinan la compatibilidad: **interfaces** y **funciones de callback**.

- Si un contrato de módulo tiene una función de callback que el contrato base no soporta (o que ya está en uso), no se puede instalar.
- De manera similar, si un contrato de módulo requiere que el contrato base soporte una determinada interfaz y no la tiene, no se puede instalar.

#### Cómo se Comunican los Contratos Base y de Módulos

Los contratos base exponen sus funciones de callback y interfaces soportadas a través de dos métodos:

- `getSupportedCallbackFunctions` - para exponer las funciones de callback soportadas por el contrato base.
- `supportsInterface` - para exponer las interfaces soportadas por el contrato base.

Los contratos de módulos también exponen sus funciones de callback y fallback suministradas, junto con las interfaces requeridas, a través de la función `getModuleConfig`.

#### Ejemplo: Interacción entre Contratos Base y de Módulos

Vamos a ver un ejemplo con tres contratos:

- `ERC721Core`
- `MintableModule`
- `TransferableModule`

##### Ejemplo de `ERC721Core`

El contrato `ERC721Core` soporta el callback `beforeMint` y la interfaz ERC-721 (`0x80ac58cd`).

```solidity
function getSupportedCallbackFunctions()
	public
	pure
	override
	returns (SupportedCallbackFunction[] memory supportedCallbackFunctions)
{
	supportedCallbackFunctions = new SupportedCallbackFunction ;
	supportedCallbackFunctions[0] = SupportedCallbackFunction({
		selector: BeforeMintCallback.beforeMint.selector,
		mode: CallbackMode.REQUIRED
	});
}

function supportsInterface(bytes4 interfaceId)
	public
	view
	override(ERC721AUpgradeable, IERC721AUpgradeable, Core)
	returns (bool)
{
	return interfaceId == 0x80ac58cd // ERC165 Interface ID for ERC721
		|| super.supportsInterface(interfaceId);
}
```

##### Ejemplo de `MintableModule`

El `MintableModule` proporciona el callback `beforeMint` y requiere la interfaz ERC-721.

```solidity
function getModuleConfig() external pure override returns (ModuleConfig memory config) {
	config.callbackFunctions = new CallbackFunction ;
	config.callbackFunctions[0] = CallbackFunction(this.beforeMint.selector);

	config.requiredInterfaces = new bytes4 ;
	config.requiredInterfaces[0] = 0x80ac58cd; // ERC721.
}
```

##### Ejemplo de `TransferableModule`

El `TransferableModule` proporciona el callback `beforeTransfer` y también requiere la interfaz ERC-721.

```solidity
function getModuleConfig() external pure override returns (ModuleConfig memory config) {
	config.callbackFunctions = new CallbackFunction ;
	config.callbackFunctions[0] = CallbackFunction(this.beforeTransfer.selector);

	config.requiredInterfaces = new bytes4 ;
	config.requiredInterfaces[0] = 0x80ac58cd; // ERC721.
}
```

##### Compatibilidad en Acción

El contrato `ERC721Core` es compatible con la interfaz ERC-721 (`0x80ac58cd`), que es requerida tanto por el `MintableModule` como por el `TransferableModule`.

Sin embargo, dado que `ERC721Core` solo soporta el callback `beforeMint`, solo el `MintableModule` puede ser instalado. El `TransferableModule`, que proporciona el callback `beforeTransfer`, no puede ser instalado porque `ERC721Core` no lo soporta.

---

#### Conclusión

Los contratos modulares funcionan permitiendo que los contratos base interactúen con los contratos módulo a través de llamadas delegadas a las funciones `fallback` y `callback`. La compatibilidad entre los contratos base y los módulos se determina por las interfaces y funciones de callback que soportan. Esta arquitectura modular proporciona flexibilidad, permitiendo que se agregue o elimine funcionalidad según sea necesario, como ensamblar o desensamblar piezas de Lego.

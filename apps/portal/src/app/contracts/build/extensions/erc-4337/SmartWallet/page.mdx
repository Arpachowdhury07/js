import { Details, Callout, GithubButtonLink } from "@doc";
import { createMetadata } from "@doc";

export const metadata = createMetadata({
	image: {
		title: "Contrato BaseAccount",
		icon: "solidity",
	},
	title: "BaseAccount | contrato de thirdweb",
	description:
		"El contrato BaseAccount es una extensión que está destinada a ser utilizada al crear tu propio contrato de cuenta inteligente que no utilice uno de nuestros contratos base para cuentas inteligentes listos para usar.",
});


# BaseAccount

```solidity
import "@thirdweb-dev/contracts/smart-wallet/utils/BaseAccount.sol";
```

El contrato inteligente `BaseAccount` es una extensión que está destinada a ser utilizada al crear tu propio contrato de cuenta inteligente que no utilice uno de nuestros contratos base para cuentas inteligentes listos para usar.

Es abstracto, lo que te permite personalizar la funcionalidad para tu caso de uso.

<Callout title="info" variant="info">
	Esta extensión de contrato inteligente se ajusta a la interfaz `IAccount`, la cual es
	detectable en el panel como la extensión `SmartWallet`.
</Callout>

<br />

<GithubButtonLink
	href="https://github.com/thirdweb-dev/contracts/blob/main/contracts/prebuilts/account/utils/BaseAccount.sol"
	name="BaseAccount"
/>

## Uso

La extensión `BaseAccount` es un _contrato abstracto_, y espera que implementes las siguientes funciones por ti mismo:

| Nombre               | Tipo        | Descripción                                             |
| -------------------- | ----------- | ------------------------------------------------------- |
| `entryPoint`         | public view | Devuelve el entryPoint actual utilizado por esta cuenta. |
| `_validateSignature` | internal    | Valida que la firma sea válida para este mensaje.       |
| `_validateNonce`     | internal    | Valida el nonce de la operación de usuario.             |

Este es un ejemplo de contrato inteligente tipo fábrica que demuestra cómo heredar de esta extensión y sobrescribir las funciones para agregar (opcionalmente) funcionalidades personalizadas.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@thirdweb-dev/contracts/smart-wallet/utils/BaseAccountFactory.sol";

contract MyAccountFactory is BaseAccountFactory { ... }
```

## Uso del SDK

Esta extensión desbloquea el uso de la [cuenta inteligente](wallet/smart-wallet) en el SDK de billetera.

## Contratos Base que Implementan Esta Extensión

- [ManagedAccount](/contracts/build/base-contracts/erc-4337/managed-account)
- [Account](/contracts/build/base-contracts/erc-4337/account)

## Referencia Completa de la API

<Details summary="getNonce">

Este método devuelve el siguiente nonce secuencial.

```solidity
function getNonce() public view virtual returns (uint256) {
    return entryPoint().getNonce(address(this), 0);
}
```

</Details>

<Details summary="entryPoint">

La subclase debe devolver el `entryPoint` actual utilizado por esta cuenta.

```solidity
function entryPoint() public view virtual returns (IEntryPoint);
```

</Details>

<Details summary="validateUserOp">

Valida la firma y el nonce del usuario.

La subclase no necesita sobrescribir este método. En su lugar, debe sobrescribir los métodos de validación internos específicos.

```solidity
function validateUserOp(
    UserOperation calldata userOp,
    bytes32 userOpHash,
    uint256 missingAccountFunds
) external virtual override returns (uint256 validationData) {
    _requireFromEntryPoint();
    validationData = _validateSignature(userOp, userOpHash);
    _validateNonce(userOp.nonce);
    _payPrefund(missingAccountFunds);
}
```

</Details>

<Details summary="_requireFromEntryPoint">

Asegúrese de que la solicitud provenga del punto de entrada conocido.

```solidity
function _requireFromEntryPoint() internal view virtual {
    require(msg.sender == address(entryPoint()), "account: not from EntryPoint");
}
```

</Details>

<Details summary="_validateSignature">

Valide que la firma sea válida para este mensaje.

```solidity
function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash)
    internal
    virtual
    returns (uint256 validationData);
```

#### userOp

Valida el campo userOp.signature

#### userOpHash

El hash de la solicitud, para verificar la firma (también hash del entrypoint y del id de la cadena)

### Valor de retorno

firma y el rango de tiempo de esta operación:

- `sigAuthorizer` - 0 para firma válida, 1 para marcar error en la firma, de lo contrario, una dirección de un contrato "authorizer".
- `validUntil` - última marca de tiempo en que esta operación es válida. 0 para "indefinido"
- `validAfter` - primera marca de tiempo en que esta operación es válida.

</Details>

<Details summary="_validateNonce">

Valida el nonce de la UserOperation.
Para limitar el nonce para usar solo UserOps secuenciales (sin "UserOps fuera de orden"):

- `require(nonce < type(uint64).max)`

Para una cuenta hipotética que _requiere_ que el nonce sea fuera de orden:

- `require(nonce & type(uint64).max == 0)`

La unicidad del nonce real es gestionada por el EntryPoint, por lo que no se necesita ninguna otra acción por parte de la cuenta misma.

```solidity
function _validateNonce(uint256 nonce) internal view virtual {}
```

#### nonce

`uint256` que representa el nonce a validar.

</Details>

<Details summary="_payPrefund">

Envía al punto de entrada (msg.sender) los fondos faltantes para esta transacción.
La subclase PUEDE anular este método para una mejor gestión de fondos.

Por ejemplo, enviar al EntryPoint más de lo mínimo requerido, para que en futuras transacciones no sea necesario enviar nuevamente.

```solidity
function _payPrefund(uint256 missingAccountFunds) internal virtual {
    if (missingAccountFunds != 0) {
        (bool success, ) = payable(msg.sender).call{ value: missingAccountFunds, gas: type(uint256).max }("");
        (success);
        //ignore failure (its EntryPoint's job to verify, not account.)
    }
}
```

#### missingAccountFunds

El valor mínimo que este método debe enviar al punto de entrada.
Este valor PUEDE ser cero, en caso de que haya suficiente depósito, o si el `userOp` tiene un "paymaster".

</Details>

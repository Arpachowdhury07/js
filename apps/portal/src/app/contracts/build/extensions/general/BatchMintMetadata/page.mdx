import { Details, createMetadata, GithubButtonLink } from "@doc";

export const metadata = createMetadata({
	image: {
		title: "Contrato BatchMintMetadata",
		icon: "solidity",
	},
	title: "BatchMintMetadata | Contrato de thirdweb",
	description:
		"El contrato inteligente BatchMintMetadata es una extensión para cualquier contrato NFT. Permite que el contrato inteligente que usa esta extensión establezca los metadatos para n número de NFTs en una sola transacción",
});


# BatchMintMetadata (ERC1155 & ERC721)

```solidity
import "@thirdweb-dev/contracts/extension/BatchMintMetadata.sol";
```

El contrato inteligente `BatchMintMetadata` es una extensión para cualquier contrato NFT. Permite que el contrato inteligente que usa esta extensión establezca los metadatos para `n` número de NFTs en una sola transacción. Se define una URI base para un lote de `n` NFTs, donde la URI de metadatos para cada NFT en un lote relevante es `baseURI/tokenId`.

<GithubButtonLink href="https://github.com/thirdweb-dev/contracts/blob/main/contracts/extension/BatchMintMetadata.sol" />

## Uso

Este es un contrato inteligente de ejemplo que demuestra cómo heredar de esta extensión y sobrescribir las funciones para agregar (opcionalmente) funcionalidad personalizada.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@thirdweb-dev/contracts/extension/BatchMintMetadata.sol";

contract MyContract is BatchMintMetadata {}
```

## Contratos Base que Implementan Esta Extensión

Ninguno de los contratos base implementa esta extensión.

## Referencia Completa de la API

<Details summary="getBaseURICount">

```solidity
function getBaseURICount() public view returns (uint256);
```
- Devuelve el número total de lotes de NFTs, donde cada lote tiene una única URI base y los metadatos de los NFTs en el lote se almacenan como `baseURI/tokenId`.
- Este valor se actualiza cuando los metadatos de un nuevo conjunto de NFTs son 'acuñados por lotes' usando la función `_batchMintMetadata`.

</Details>

<Details summary="getBatchIdAtIndex">

```solidity
function getBatchIdAtIndex(uint256 _index) public view returns (uint256);
```

- El contrato inteligente de la extensión almacena un arreglo de 'IDs de lotes', es decir, IDs para diferentes lotes de NFTs acuñados en el contrato. Esta función devuelve el ID del lote en un índice dado de este arreglo ordenado de IDs de lotes.

</Details>

<Details summary="_getBatchId">

```solidity
function _getBatchId(uint256 tokenId) internal view returns (uint256 batchId, uint256 index);
```

- Devuelve el ID del lote para el lote de NFTs al que pertenece el `tokenId` dado.
- Parámetro `tokenId`: el `tokenId` para el cual recuperar el ID de lote asociado.

</Details>

<Details summary="_getBaseURI">

```solidity
function _getBaseURI(uint256 _tokenId) internal view returns (string memory);
```

- Devuelve la URI base de metadatos para el `tokenId` dado.
- Parámetro `tokenId`: el `tokenId` para el cual recuperar la URI base de metadatos asociada.

</Details>

<Details summary="_setBaseURI">

```solidity
function _setBaseURI(uint256 batchId, string memory baseURI) internal;
```

- Actualiza la URI base de metadatos para un lote dado de NFTs.
- Parámetro `batchID`: el ID del lote de NFTs cuyo URI de metadatos se actualizará.
- Parámetro `baseURI`: el valor que se establecerá como la nueva URI base para el lote relevante de NFTs.

</Details>

<Details summary="_batchMintMetadata">

```solidity
function _batchMintMetadata(
    uint256 _startId,
    uint256 _amountToMint,
    string memory _baseURIForTokens
) internal returns (uint256 nextTokenIdToMint, uint256 batchId);
```

- Acuña un lote de `tokenIds` y asocia una URI base común a todos esos IDs.
- Parámetro `_startId`: El tokenId más bajo del lote de NFTs a acuñar. Se supone que los tokenIds se asignan a los NFTs en orden serial, cuando se acuñan por lotes, por ejemplo, `[startId, startId + 1, ... n-1, n]`.
- Parámetro `_amountToMint`: El número de NFTs a acuñar a la vez.
- Parámetro `_baseURIForTokens`: La URI base común para el lote de NFTs que se están acuñando, donde para un lote de NFTs con tokenIds `[startId, startId + 1, ... n-1, n]`, la URI de metadatos asociada para cada NFT es `[baseURI/startId, baseURI/startId+1, ... baseURI/n-1, baseURI/n]`.

</Details>

import { Details, GithubButtonLink } from "@doc";
import { createMetadata } from "@doc";

export const metadata = createMetadata({
	image: {
		title: "Contrato ERC721Staking",
		icon: "solidity",
	},
	title: "ERC721Staking | contrato de thirdweb",
	description:
		"La extensión del contrato Staking721 implementa el mecanismo de staking para NFTs. Con esta extensión, puedes configurar un contrato de staking para los poseedores de NFTs de tu colección ERC721.",
});


# ERC721Staking

```solidity
import "@thirdweb-dev/contracts/extension/Staking721.sol";
```

La extensión del contrato `Staking721` implementa el mecanismo de staking para NFTs. Con esta extensión, puedes configurar un contrato de staking para los poseedores de NFTs de tu colección ERC721. Los usuarios pueden hacer staking de sus NFTs y ganar tokens ERC20 como recompensas.

<GithubButtonLink href="https://github.com/thirdweb-dev/contracts/blob/main/contracts/extension/Staking721.sol" />

## Uso

Este es un ejemplo de contrato inteligente que demuestra cómo heredar de esta extensión y sobrescribir las funciones para agregar (de forma opcional) funcionalidad personalizada.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@thirdweb-dev/contracts/extension/Staking721.sol";
import "@thirdweb-dev/contracts/eip/interface/IERC20.sol";

contract MyContract is Staking721 {
    // ERC20 Reward Token address. See {_mintRewards}.
    address public rewardToken;

    /**
     *  Almacenamos la dirección del desplegador del contrato solo para los fines del ejemplo
     *  en el comentario de código a continuación.
     *
     *  Hacer esto no es necesario para usar la extensión `Staking721`.
     */
    address public deployer;

    constructor(
        uint256 _timeUnit,
        uint256 _rewardsPerUnitTime,
        address _stakingToken,
        address _rewardToken
    ) Staking721(_stakingToken) {
        _setStakingCondition(_timeUnit, _rewardsPerUnitTime);

        rewardToken = _rewardToken;
        deployer = msg.sender;
    }

    /**
     *  @dev    Minta/Transfiere recompensas ERC20 al staker. Debe ser sobreescrito.
     *
     *  @param _staker    Dirección a la que se enviarán las recompensas.
     *  @param _rewards   Cantidad de tokens a entregar como recompensa.
     *
     */
    function _mintRewards(address _staker, uint256 _rewards) internal override {
        IERC20(rewardToken).transfer(_staker, _rewards);
    }

    // Returns whether staking restrictions can be set in given execution context.
    function _canSetStakeConditions() internal view override returns (bool) {
        return msg.sender == deployer;
    }
}
```

## Contratos Base que Implementan Esta Extensión

- [Staking721Base](/contracts/build/base-contracts/erc-721/staking)

## Referencia Completa de la API

<Details summary="stake">

```solidity
function stake(uint256[] calldata tokenIds) external;
```

- Permite a un usuario apostar una cantidad de tokens ERC721 pasando los identificadores de los tokens.
- Parámetro `tokenIds`: Lista de identificadores de los tokens para apostar.

</Details>

<Details summary="withdraw">

```solidity
function withdraw(uint256[] calldata tokenIds) external;
```

- Deshacer la apuesta y retirar NFTs del contrato.
- Parámetro `tokenIds`: Lista de identificadores de los tokens para retirar.

</Details>

<Details summary="claimRewards">

```solidity
function claimRewards() external;
```

- Reclamar las recompensas acumuladas. Este método de reclamo permite un mecanismo de "pull", donde los usuarios deben iniciar el reclamo de recompensas.

</Details>

<Details summary="getStakeInfo">

```solidity
function getStakeInfo(address staker) external view returns (uint256 tokensStaked, uint256 rewards);
```

- Ver la cantidad de NFTs apostados y las recompensas totales disponibles para un usuario.
- Parámetro `staker`: Dirección de la cuenta del apostador.

</Details>

<Details summary="setRewardsPerUnitTime">

```solidity
function setRewardsPerUnitTime(uint256 rewardsPerUnitTime) external;
```

- Permite que una cuenta autorizada establezca las recompensas por unidad de tiempo. Interpretado como x recompensas por segundo/día/etc. según la unidad de tiempo.
- Parámetro `rewardsPerUnitTime`: Nuevas recompensas por unidad de tiempo.

</Details>

<Details summary="setTimeUnit">

```solidity
function setTimeUnit(uint256 timeUnit) external;
```

- Permite que una cuenta autorizada establezca la unidad de tiempo como un número de segundos. Por ejemplo, 1 hora puede establecerse como 3600 segundos, estableciendo la frecuencia de recompensas como _por hora_.
- Parámetro `timeUnit`: Nueva unidad de tiempo.

</Details>

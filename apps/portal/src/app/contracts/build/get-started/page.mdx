import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs";
import { createMetadata } from "@doc";

export const metadata = createMetadata({
	image: { title: "Comenzando con thirdweb Solidity SDK", icon: "solidity" },
	title: "Comenzando con thirdweb Solidity SDK",
	description:
		"Para comenzar con el Solidity SDK, ejecuta el siguiente comando para crear un nuevo proyecto:",
});

# Primeros Pasos

Para comenzar con el Solidity SDK, ejecuta el siguiente comando para crear un nuevo proyecto:

```bash
npx thirdweb create contract
```

O, instala el paquete `contracts` en tu proyecto Solidity existente:

<Tabs defaultValue="forge">

<TabsList>
	<TabsTrigger value="forge">Forge</TabsTrigger>
	<TabsTrigger value="hardhat">Hardhat</TabsTrigger>
</TabsList>

<TabsContent value="forge">
```bash
forge install https://github.com/thirdweb-dev/contracts
```
</TabsContent>
<TabsContent value="hardhat">
```bash
npm i @thirdweb-dev/contracts
```
</TabsContent>
</Tabs>

## Usando el Solidity SDK

El Solidity SDK se puede usar para crear nuevos contratos inteligentes _de principio a fin_, o para agregar funcionalidad a tu propio contrato inteligente existente utilizando [extensiones](/contracts/build/extensions).

Todas las funciones en los [contratos base](/contracts/build/base-contracts) y [extensiones](/contracts/build/extensions) pueden ser modificadas [sobrescribiéndolas](/contracts/build/get-started#herencia-y-sobrescritura-de-funciones).

### Usando Contratos Base

El Solidity SDK incluye [contratos base](/contracts/build/base-contracts) que son contratos inteligentes completamente terminados que se pueden personalizar sobrescribiendo funciones O agregando extensiones.

**1.** Para comenzar, importa y hereda el contrato base. Puedes encontrar la lista de todos los contratos base disponibles [aquí](/contracts/build/base-contracts).

**2.** Los contratos base esperan ciertos argumentos en el constructor para funcionar como se espera. Implementa un constructor para tu contrato inteligente y pasa los valores apropiados al constructor del contrato base.


```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@thirdweb-dev/contracts/base/ERC721Base.sol";

contract MyNFT is ERC721Base {
    constructor(
        address _defaultAdmin,
        string memory _name,
        string memory _symbol,
        address _royaltyRecipient,
        uint128 _royaltyBps
    ) ERC721Base(_defaultAdmin, _name, _symbol, _royaltyRecipient, _royaltyBps) {}
}
```

**3.** ¡Ahora estás listo! 🎉 ¡Tu contrato inteligente ahora tiene todas las [extensiones](/contracts/build/extensions) proporcionadas por el [contrato base](/contracts/build/base-contracts) que hereda y está listo para ser [desplegado](/contracts/deploy/overview) en cualquier blockchain EVM de tu elección!

### Usando Extensiones

Las extensiones se deben usar mediante herencia: el contrato inteligente de tu proyecto heredará de ellas.

Se pueden agregar [extensiones](/contracts/build/extensions) adicionales a contratos inteligentes existentes o a los [contratos base](/contracts/build/base-contracts) para agregar funcionalidad adicional y desbloquear características en los SDK y el Panel de Control.

**1.** Para comenzar, importa y hereda la extensión. Puedes encontrar la lista de todas las extensiones disponibles [aquí](/contracts/build/extensions).

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@thirdweb-dev/contracts/base/ERC721Base.sol";
import "@thirdweb-dev/contracts/extension/Permissions.sol";

contract MyNFT is ERC721Base, Permissions {
    constructor(
        address _defaultAdmin,
        string memory _name,
        string memory _symbol,
        address _royaltyRecipient,
        uint128 _royaltyBps
    ) ERC721Base(_defaultAdmin, _name, _symbol, _royaltyRecipient, _royaltyBps) {}
}
```

**Notas:**

- Algunas extensiones son **abstractas** y por lo tanto requieren que se implementen ciertas funciones*.
- Algunas extensiones son **interfaces** y por lo tanto requieren que se implementen **todas** las funciones*.

\*implementar = escribir la lógica para la función con una firma de función coincidente (nombre, parámetros, visibilidad y tipo de retorno coincidentes)

**2.** Usa las funciones proporcionadas por la extensión para cambiar el comportamiento de tu contrato inteligente.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@thirdweb-dev/contracts/base/ERC721Base.sol";
import "@thirdweb-dev/contracts/extension/Permissions.sol";

contract MyNFT is ERC721Base, Permissions {
    bytes32 private constant MINTER_ROLE = keccak256("MINTER_ROLE");

    constructor(
        address _defaultAdmin,
        string memory _name,
        string memory _symbol,
        address _royaltyRecipient,
        uint128 _royaltyBps
    ) ERC721Base(_defaultAdmin, _name, _symbol, _royaltyRecipient, _royaltyBps) {}

    /**
     *  `_canMint` is a function available in `ERC721Base`.
     *
     * Se llama cada vez que una billetera intenta acuñar NFTs en este
     * contrato, y te permite definir la condición en la que un
     * intento de acuñar NFTs debe ser permitido o rechazado.
     *
     * Por defecto, `ERC721Base` solo permite que el propietario del contrato acuñe
     * NFTs. Aquí, sobrecargamos esa funcionalidad.
     *
     * Usamos la extensión `Permissions` para especificar que cualquier persona que tenga
     * el "MINTER_ROLE" debería poder acuñar NFTs.
     */
    function _canMint() internal view override returns (bool) {
        return hasRole(MINTER_ROLE, msg.sender);
    }
}
```

### Herencia y Sobrescritura de Funciones

La herencia permite que tu contrato inteligente extienda las propiedades de tu contrato, incluyendo los atributos y propiedades del contrato padre.
Las funciones heredadas de este contrato padre pueden ser modificadas en el contrato hijo mediante un proceso conocido como sobrescritura.

Contrato padre: El contrato del que el contrato hijo hereda.

Contrato hijo: El contrato que hereda.

Para sobrescribir una función y agregar tu propia lógica personalizada, simplemente usa la palabra clave `override` al declarar la función, asegurándote de que la firma de la función coincida.
Para agregar la lógica original del contrato padre, usa la palabra clave `super`.

Por ejemplo, el contrato [`ERC721Base`](/contracts/build/base-contracts/erc-721/base) tiene una implementación de la función `mintTo`. Podría sobrescribir esta función para agregar lógica personalizada
y restringir esta función en el contrato `myNFT` para permitir solo 1 NFT por billetera:


```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@thirdweb-dev/contracts/base/ERC721Base.sol";
import "@thirdweb-dev/contracts/extension/Permissions.sol";

contract MyNFT is ERC721Base, Permissions {
    constructor(
        address _defaultAdmin,
        string memory _name,
        string memory _symbol,
        address _royaltyRecipient,
        uint128 _royaltyBps
    ) ERC721Base(_defaultAdmin, _name, _symbol, _royaltyRecipient, _royaltyBps) {}

    function mintTo(address _to, string memory _tokenURI) public override {
        require(balanceOf(_to) < 1, "only 1 NFT per wallet!");
        super.mintTo(_to, _tokenURI);
    }
}
```

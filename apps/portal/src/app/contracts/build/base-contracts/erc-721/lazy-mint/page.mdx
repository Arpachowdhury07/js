import { Details } from "@doc";
import { GithubButtonLink } from "@doc";
import { createMetadata } from "@doc";

export const metadata = createMetadata({
	image: {
		title: "ERC721LazyMint contract",
		icon: "contract",
	},
	title: "ERC721LazyMint | thirdweb contracts",
	description:
		"ERC721LazyMint permite realizar un minting diferido de tokens ERC-721, lo que permite que cualquier billetera reclame un NFT con minting diferido",
});

# ERC721LazyMint

```solidity
import "@thirdweb-dev/contracts/base/ERC721LazyMint.sol";
```

`ERC721LazyMint` te permite realizar un minting diferido de tokens ERC-721, lo que permite que cualquier billetera reclame un NFT con minting diferido.  
Expone una función `verifyClaim` que puedes sobrescribir para agregar tu propia lógica de restricción de reclamaciones.

El minting diferido te permite definir los metadatos de los NFTs sin tener que hacer el minting en una dirección.  
Como administrador del contrato, esto te permite preparar los metadatos de los NFTs que serán mintados por otras billeteras,  
sin tener que pagar el costo de gas por el minting real de los NFTs.

<GithubButtonLink href="https://github.com/thirdweb-dev/contracts/blob/main/contracts/base/ERC721LazyMint.sol" />

## Uso

Importa el contrato y hereda de él.

```solidity
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import "@thirdweb-dev/contracts/base/ERC721LazyMint.sol";

contract MyNFT is ERC721LazyMint {
    constructor(
        address _defaultAdmin,
        string memory _name,
        string memory _symbol,
        address _royaltyRecipient,
        uint128 _royaltyBps
    ) ERC721LazyMint(_defaultAdmin, _name, _symbol, _royaltyRecipient, _royaltyBps) {}

    function verifyClaim(address _claimer, uint256 _quantity) public view virtual override {
      // Your custom claim restriction logic
    }
}
```

## Extensiones Detectadas

Una vez que se haya desplegado, puedes usar las características habilitadas por estas extensiones en el SDK y en el panel de control:

Haz clic en cada característica para aprender más sobre qué funciones están disponibles.

- [ERC721](/contracts/build/extensions/erc-721/ERC721)
- [ERC721Burnable](/contracts/build/extensions/erc-721/ERC721Burnable)
- [ERC721ClaimCustom](/contracts/build/extensions/erc-721/ERC721ClaimCustom)
- [ERC721Supply](/contracts/build/extensions/erc-721/ERC721Supply)
- [Royalty](/contracts/build/extensions/general/Royalty)
- [ContractMetadata](/contracts/build/extensions/general/ContractMetadata)
- [Ownable](/contracts/build/extensions/general/Ownable)

## Funciones a Sobrescribir

Las siguientes funciones han sido implementadas en este contrato y están disponibles para ser sobrescritas para agregar lógica personalizada:

<Details id="tokenURI" summary="tokenURI">
```solidity
/**
*  @notice         Devuelve la URI de metadatos para un NFT.
*  @dev            Consulta `BatchMintMetadata` para el manejo de los metadatos en este contrato.
*
*  @param _tokenId El tokenId de un NFT.
*/
function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
    string memory batchUri = _getBaseURI(_tokenId);
    return string(abi.encodePacked(batchUri, _tokenId.toString()));
}
```
</Details>

<Details id="claim" summary="claim">

```solidity
/**
*  @notice          Permite a una dirección reclamar múltiples NFTs mintados de manera perezosa de una vez a un receptor.
*                   Esta función previene cualquier llamada reentrante, y no se puede sobrescribir.
*
*                   Los creadores de contratos deben sobrescribir las funciones `verifyClaim` y `transferTokensOnClaim`
*                   para crear una lógica personalizada para la verificación y la reclamación,
*                   por ejemplo, recolección de precios, listas permitidas, cantidad máxima, etc.
*
*  @dev             La lógica en `verifyClaim` determina si la llamada es autorizada para mintar NFTs.
*                   La lógica en `transferTokensOnClaim` realiza el minting de los tokens,
*                   también puede ser utilizada para aplicar otros cambios de estado.
*
*  @param _receiver  El destinatario del NFT a mintar.
*  @param _quantity  La cantidad de NFTs a mintar.
*/
function claim(address _receiver, uint256 _quantity) public payable nonReentrant {
    require(_currentIndex + _quantity <= nextTokenIdToLazyMint, "Not enough lazy minted tokens.");
    verifyClaim(msg.sender, _quantity); // Add your claim verification logic by overriding this function.

    uint256 startTokenId = _transferTokensOnClaim(_receiver, _quantity); // Mints tokens. Apply any state updates by overriding this function.
    emit TokensClaimed(msg.sender, _receiver, startTokenId, _quantity);
}
```

</Details>

<Details id="verifyClaim" summary="verifyClaim">

```solidity
/**
     *  @notice          Sobrescribe esta función para agregar la lógica de verificación de la reclamación,
     *                   basada en condiciones como lista permitida, precio, cantidad máxima, etc.
     *
     *  @dev             Verifica una solicitud para reclamar NFTs contra una condición personalizada.
     *
     *  @param _claimer   Llamante de la función de reclamación.
     *  @param _quantity  La cantidad de NFTs que se están reclamando.
 */
    function verifyClaim(address _claimer, uint256 _quantity) public view virtual {}
```

</Details>

<Details id="burn" summary="burn">

```solidity
/**
*  @notice         Permite que un propietario o un operador aprobado queme el NFT del tokenId dado.
*  @dev            El método `_burn(uint256,bool)` de ERC721A verifica internamente las aprobaciones de los tokens.
*
*  @param _tokenId El tokenId del NFT que se va a quemar.
*/
function burn(uint256 _tokenId) external virtual {
    _burn(_tokenId, true);
}
```

</Details>

<Details id="_transferTokensOnClaim" summary="_transferTokensOnClaim">

```solidity
/**
*  @notice          Minta tokens al receptor al reclamar.
*                   Cualquier cambio de estado relacionado con `claim` debe aplicarse
*                   aquí sobrecargando esta función.
*
*  @dev             Sobrecarga esta función para agregar lógica de actualización de estado.
*                   Al sobrecargar, aplica cualquier cambio de estado antes de `_safeMint`.
*/
function _transferTokensOnClaim(address _receiver, uint256 _quantity)
    internal
    virtual
    returns (uint256 startTokenId)
{
    startTokenId = _currentIndex;
    _safeMint(_receiver, _quantity);
}
```

</Details>

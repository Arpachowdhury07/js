import { Details } from "@doc";
import { GithubButtonLink } from "@doc";
import { createMetadata } from "@doc";

export const metadata = createMetadata({
	image: {
		title: "ERC721DelayedReveal contract",
		icon: "contract",
	},
	title: "ERC721DelayedReveal | thirdweb contracts",
	description:
		"ERC721DelayedReveal añade la funcionalidad de Revelado Retrasado al contrato base ERC721LazyMint.",
});

# ERC721DelayedReveal

`ERC721DelayedReveal` añade la característica de [Revelado Retrasado](/contracts/build/extensions/general/DelayedReveal) al
contrato base [ERC721LazyMint](/contracts/build/base-contracts/erc-721/lazy-mint).

```solidity
import "@thirdweb-dev/contracts/base/ERC721DelayedReveal.sol";
```

<GithubButtonLink href="https://github.com/thirdweb-dev/contracts/blob/main/contracts/base/ERC721DelayedReveal.sol" />

## Uso

Importa el contrato y herédalo de él.

```solidity
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import "@thirdweb-dev/contracts/base/ERC721DelayedReveal.sol";

contract MyNFT is ERC721DelayedReveal {
    constructor(
        address _defaultAdmin,
        string memory _name,
        string memory _symbol,
        address _royaltyRecipient,
        uint128 _royaltyBps
    ) ERC721DelayedReveal(_defaultAdmin, _name, _symbol, _royaltyRecipient, _royaltyBps) {}

    function verifyClaim(address _claimer, uint256 _quantity) public view virtual override {
      // Your custom claim restriction logic
    }
}
```

## Extensiones detectadas

Una vez implementado, puedes usar las funciones disponibles de estas extensiones en el SDK y el panel de control:

Haz clic en cada función para aprender más sobre qué funciones están disponibles.

- [ERC721](/contracts/build/extensions/erc-721/ERC721)
- [ERC721Burnable](/contracts/build/extensions/erc-721/ERC721Burnable)
- [ERC721Revealable](/contracts/build/extensions/general/DelayedReveal)
- [ERC721Supply](/contracts/build/extensions/erc-721/ERC721Supply)
- [ERC721ClaimCustom](/contracts/build/extensions/erc-721/ERC721ClaimCustom)
- [Royalty](/contracts/build/extensions/general/Royalty)
- [ContractMetadata](/contracts/build/extensions/general/ContractMetadata)
- [Ownable](/contracts/build/extensions/general/Ownable)

## Funciones para sobrescribir

Las siguientes funciones se han implementado en este contrato y están disponibles para ser sobrescritas con lógica personalizada:

<Details id="tokenURI" summary="tokenURI">

```solidity
/**
 *  @notice         Devuelve la URI de metadatos para un NFT.
 *  @dev            Consulta `BatchMintMetadata` para el manejo de metadatos en este contrato.
 *
 *  @param _tokenId El tokenId de un NFT.
 */
function tokenURI(uint256 _tokenId) public view override returns (string memory) {
    (uint256 batchId, ) = _getBatchId(_tokenId);
    string memory batchUri = _getBaseURI(_tokenId);

    if (isEncryptedBatch(batchId)) {
        return string(abi.encodePacked(batchUri, "0"));
    } else {
        return string(abi.encodePacked(batchUri, _tokenId.toString()));
    }
}

```

</Details>

<Details id="lazyMint" summary="lazyMint">

```solidity
/**
 *  @notice                  Permite a una dirección autorizada acuñar perezosamente una cantidad dada de NFTs.
 *
 *  @param _amount           La cantidad de NFTs a acuñar perezosamente.
 *  @param _baseURIForTokens La URI base de marcador de posición para los 'n' NFTs que se están acuñando perezosamente, donde los
 *                           metadatos de cada uno de esos NFTs son `${baseURIForTokens}/${tokenId}`.
 *  @param _data             La URI base cifrada + el hash de la procedencia para el lote de NFTs que se están acuñando perezosamente.
 *  @return batchId          Un identificador único entero para el lote de NFTs acuñados perezosamente juntos.
 */
function lazyMint(
    uint256 _amount,
    string calldata _baseURIForTokens,
    bytes calldata _data
) public override returns (uint256 batchId) {
    if (_data.length > 0) {
        (bytes memory encryptedURI, bytes32 provenanceHash) = abi.decode(_data, (bytes, bytes32));
        if (encryptedURI.length != 0 && provenanceHash != "") {
            _setEncryptedData(nextTokenIdToLazyMint + _amount, _data);
        }
    }

    return super.lazyMint(_amount, _baseURIForTokens, _data);
}
```

</Details>

<Details id="reveal" summary="reveal">

```solidity
/**
 *  @notice       Permite a una dirección autorizada revelar un lote de NFTs de revelación retrasada.
 *
 *  @param _index El ID para el lote de NFTs de revelación retrasada a revelar.
 *  @param _key   La clave con la que se cifró la URI base para el lote relevante de NFTs.
 */
function reveal(uint256 _index, bytes calldata _key) external virtual override returns (string memory revealedURI) {
    require(_canReveal(), "Not authorized");

    uint256 batchId = getBatchIdAtIndex(_index);
    revealedURI = getRevealURI(batchId, _key);

    _setEncryptedData(batchId, "");
    _setBaseURI(batchId, revealedURI);

    emit TokenURIRevealed(_index, revealedURI);
}
```

</Details>

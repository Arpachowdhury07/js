import { Details } from "@doc";
import { GithubButtonLink } from "@doc";
import { createMetadata } from "@doc";

export const metadata = createMetadata({
	image: {
		title: "ERC721Drop contract",
		icon: "contract",
	},
	title: "ERC721Drop | thirdweb contracts",
	description:
		"El contrato base ERC721Drop te permite crear un NFT Drop que otras billeteras pueden reclamar.",
});

# ERC721Drop

```solidity
import "@thirdweb-dev/contracts/base/ERC721Drop.sol";
```

# ERC721Drop

El contrato base `ERC721Drop` te permite crear un NFT Drop que otras billeteras pueden reclamar.

Implementa el estándar [ERC721A](/contracts/build/extensions/erc-721/ERC721) con las extensiones de [Lazy Mint](/contracts/build/extensions/general/LazyMint),
[Delayed Reveal](/contracts/build/extensions/general/DelayedReveal) y [Drop](/contracts/build/extensions/general/DropSinglePhase);
permitiéndote realizar un mint de NFTs de forma perezosa por lotes y permitir que otras billeteras los reclamen bajo los criterios de las condiciones de reclamo, con una revelación opcionalmente retrasada.

<GithubButtonLink href="https://github.com/thirdweb-dev/contracts/blob/main/contracts/base/ERC721Drop.sol" />

## Uso

Importa el contrato e implementa la herencia de él.

```solidity
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.0;

import "@thirdweb-dev/contracts/base/ERC721Drop.sol";

contract MyNFT is ERC721Drop {
    constructor(
        address _defaultAdmin,
        string memory _name,
        string memory _symbol,
        address _royaltyRecipient,
        uint128 _royaltyBps,
        address _primarySaleRecipient
    )
        ERC721Drop(
            _defaultAdmin,
            _name,
            _symbol,
            _royaltyRecipient,
            _royaltyBps,
            _primarySaleRecipient
        )
    {}
}
```

## Extensiones Detectadas

Una vez desplegado, puedes utilizar las funciones disponibles de estas extensiones en el SDK y el panel de control:

Haz clic en cada característica para aprender más sobre las funciones disponibles.

- [ERC721](/contracts/build/extensions/erc-721/ERC721)
- [ERC721Burnable](/contracts/build/extensions/erc-721/ERC721Burnable)
- [ERC721ClaimConditionsV2](/contracts/build/extensions/erc-721/ERC721ClaimConditions)
- [ERC721Revealable](/contracts/build/extensions/general/DelayedReveal)
- [ERC721Supply](/contracts/build/extensions/erc-721/ERC721Supply)
- [Royalty](/contracts/build/extensions/general/Royalty)
- [PrimarySale](/contracts/build/extensions/general/PrimarySale)
- [ContractMetadata](/contracts/build/extensions/general/ContractMetadata)
- [Ownable](/contracts/build/extensions/general/Ownable)

## Funciones a Sobrescribir

Las siguientes funciones han sido implementadas en este contrato y están disponibles para ser sobrescritas para agregar lógica personalizada:

<Details id="tokenURI" summary="tokenURI">

```solidity
/**
*  @notice         Devuelve la URI de metadatos para un NFT.
*  @dev            Consulta `BatchMintMetadata` para el manejo de los metadatos en este contrato.
*
*  @param _tokenId El tokenId de un NFT.
*/
function tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {
    (uint256 batchId, ) = _getBatchId(_tokenId);
    string memory batchUri = _getBaseURI(_tokenId);

    if (isEncryptedBatch(batchId)) {
        return string(abi.encodePacked(batchUri, "0"));
    } else {
        return string(abi.encodePacked(batchUri, _tokenId.toString()));
    }
}

```

</Details>

<Details id="lazyMint" summary="lazyMint">

```solidity
/**
*  @notice                  Permite que una dirección autorizada cree en minting perezoso una cantidad determinada de NFTs.
*
*  @param _amount           La cantidad de NFTs a crear mediante minting perezoso.
*  @param _baseURIForTokens La URI base de marcador de posición para los 'n' NFTs que se están mintiendo perezosamente, donde los
*                           metadatos de cada uno de esos NFTs son `${baseURIForTokens}/${tokenId}`.
*  @param _data             La URI base cifrada + el hash de la procedencia para el lote de NFTs siendo creados mediante minting perezoso.
*  @return batchId          Un identificador único entero para el lote de NFTs creados juntos.
*/
function lazyMint(
    uint256 _amount,
    string calldata _baseURIForTokens,
    bytes calldata _data
) public override returns (uint256 batchId) {
    if (_data.length > 0) {
        (bytes memory encryptedURI, bytes32 provenanceHash) = abi.decode(_data, (bytes, bytes32));
        if (encryptedURI.length != 0 && provenanceHash != "") {
            _setEncryptedData(nextTokenIdToLazyMint + _amount, _data);
        }
    }

    return LazyMint.lazyMint(_amount, _baseURIForTokens, _data);
}
```

</Details>

<Details id="reveal" summary="reveal">

```solidity
/**
*  @notice       Permite que una dirección autorizada revele un lote de NFTs con revelación retrasada.
*
*  @param _index El ID del lote de NFTs con revelación retrasada para revelar.
*  @param _key   La clave con la que la URI base para el lote relevante de NFTs fue cifrada.
*/
function reveal(uint256 _index, bytes calldata _key) public virtual override returns (string memory revealedURI) {
    require(_canReveal(), "Not authorized");

    uint256 batchId = getBatchIdAtIndex(_index);
    revealedURI = getRevealURI(batchId, _key);

    _setEncryptedData(batchId, "");
    _setBaseURI(batchId, revealedURI);

    emit TokenURIRevealed(_index, revealedURI);
}
```

</Details>

<Details id="burn" summary="burn">

```solidity
/**
*  @notice         Permite que un propietario o un operador aprobado queme el NFT del tokenId dado.
*  @dev            La función `_burn(uint256,bool)` de ERC721A verifica internamente las aprobaciones de tokens.
*
*  @param _tokenId El tokenId del NFT a quemar.
*/
function burn(uint256 _tokenId) external virtual {
    _burn(_tokenId, true);
}
```

</Details>

<Details id="beforeClaim" summary="beforeClaim">
```solidity
/// @dev Se ejecuta antes de cada llamada a la función `claim`.
function _beforeClaim(
    address,
    uint256 _quantity,
    address,
    uint256,
    AllowlistProof calldata,
    bytes memory
) internal view virtual override {
    if (_currentIndex + _quantity > nextTokenIdToLazyMint) {
        revert("Not enough minted tokens");
    }
}
```
</Details>

<Details id="_collectPriceOnClaim" summary="_collectPriceOnClaim">

```solidity
/// @dev Recoge y distribuye el valor de la venta principal de los NFTs que están siendo reclamados.
function _collectPriceOnClaim(
    address _primarySaleRecipient,
    uint256 _quantityToClaim,
    address _currency,
    uint256 _pricePerToken
) internal virtual override {
    if (_pricePerToken == 0) {
        return;
    }

    uint256 totalPrice = _quantityToClaim * _pricePerToken;

    if (_currency == CurrencyTransferLib.NATIVE_TOKEN) {
        if (msg.value != totalPrice) {
            revert("Must send total price");
        }
    }

    address saleRecipient = _primarySaleRecipient == address(0) ? primarySaleRecipient() : _primarySaleRecipient;
    CurrencyTransferLib.transferCurrency(_currency, msg.sender, saleRecipient, totalPrice);
}
```

</Details>

<Details id="_transferTokensOnClaim" summary="_transferTokensOnClaim">

```solidity
/// @dev Transfiere los NFTs que están siendo reclamados.
function _transferTokensOnClaim(address _to, uint256 _quantityBeingClaimed)
    internal
    virtual
    override
    returns (uint256 startTokenId)
{
    startTokenId = _currentIndex;
    _safeMint(_to, _quantityBeingClaimed);
}
```

</Details>

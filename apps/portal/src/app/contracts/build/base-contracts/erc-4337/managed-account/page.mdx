import { Details, Callout } from "@doc";
import { GithubButtonLink } from "@doc";
import { createMetadata } from "@doc";

export const metadata = createMetadata({
	image: {
		title: "Contrato de Cuenta Administrada",
		icon: "contract",
	},
	title: "Cuenta Administrada | contratos de thirdweb",
	description:
		"El contrato de Cuenta Administrada es un contrato de cuenta inteligente actualizable escrito en el patrón de contrato dinámico",
});

# Cuenta Administrada

```solidity
import "@thirdweb-dev/contracts/smart-wallet/managed/ManagedAccount.sol";
```

Este contrato hereda del contrato [`BaseAccount`](/contracts/build/extensions/erc-4337/SmartWallet).

El `ManagedAccount` es un contrato de cuenta inteligente _actualizable_ escrito en el [patrón de contrato dinámico](https://github.com/thirdweb-dev/dynamic-contracts).

Los desarrolladores de aplicaciones pueden emitir cuentas inteligentes `ManagedAccount` de manera programática mediante el despliegue de un contrato inteligente [`ManagedAccountFactory`](/contracts/build/base-contracts/erc-4337/managed-account-factory).

El administrador del contrato [`ManagedAccountFactory`](/contracts/build/base-contracts/erc-4337/managed-account-factory) puede realizar mejoras a todos los contratos `ManagedAccount` que cree. Este administrador no requiere permisos sobre la cuenta inteligente `ManagedAccount` para hacerlo.

Una mejora a las características de `ManagedAccount` se aplica a **todas** las cuentas inteligentes `ManagedAccount` creadas por la fábrica. Esta es la billetera adecuada para los desarrolladores que anticipan **realizar mejoras** en las billeteras de sus usuarios.

<GithubButtonLink href="https://github.com/thirdweb-dev/contracts/blob/main/contracts/prebuilts/account/managed/ManagedAccount.sol" />

<br />

<Callout title="Emisión de cuentas de manera programática" variant="info">

Si tienes la intención de emitir cuentas programáticamente utilizando un contrato de fábrica personalizado, debes hacer lo siguiente:

- Crea un nuevo contrato de fábrica extendiendo la extensión [BaseAccountFactory](/contracts/build/extensions/erc-4337/SmartWallet-factory).

- Sobrescribe la función `_initializeAccount` en la fábrica para crear una nueva billetera. ([referencia](https://github.com/thirdweb-dev/contracts/blob/main/contracts/smart-wallet/non-upgradeable/AccountFactory.sol#L36))

</Callout>

## Extensiones Detectadas

Una vez desplegado, puedes usar las características disponibles a través de estas extensiones en el SDK y el panel:

- [SmartWallet](/contracts/build/extensions/erc-4337/SmartWallet)
- [Multicall](/contracts/build/extensions/general/Multicall)

## Uso

Importa el contrato y haz que tu contrato herede de él. Este es un ejemplo de contrato que muestra una forma en que podrías sobrescribir la funcionalidad para crear una cuenta vinculada a un token.

```solidity
import "@thirdweb-dev/contracts/smart-wallet/managed/ManagedAccount.sol";

contract ManagedTokenBoundAccount is ManagedAccount {
    constructor(
        IEntryPoint _entrypoint
    )
        ManagedAccount(
            _entrypoint
        )
    {}
}
```

## Funciones para Sobrescribir

Las siguientes funciones han sido implementadas en este contrato y están disponibles para ser sobrescritas para agregar lógica personalizada:

<Details id="initialize" summary="initialize">

Inicializa la billetera del contrato inteligente.

```solidity
function initialize(address _defaultAdmin, bytes calldata _data) public virtual initializer {
    factory = msg.sender;
    _setupRole(DEFAULT_ADMIN_ROLE, _defaultAdmin);
}
```

#### \_defaultAdmin

El administrador de la cuenta. Debe ser de tipo `address`.

#### \_data

Los datos codificados en ABI para inicializar el contrato. Deben ser de tipo `bytes`.

</Details>

<Details id="getImplementationForFunction" summary="getImplementationForFunction">

Devuelve la dirección de implementación de la extensión, almacenada en el enrutador, para la función dada.

```solidity
function getImplementationForFunction(bytes4 _functionSelector) public view virtual override returns (address) {
    return Router(payable(factory)).getImplementationForFunction(_functionSelector);
}
```

#### \_functionSelector

El selector de la función para obtener la dirección de implementación de la extensión. Debe ser de tipo `bytes4`.

</Details>

<Details id="isValidSigner" summary="isValidSigner">

Devuelve si un firmante está autorizado para realizar transacciones usando la billetera.

```solidity
function isValidSigner(address _signer) public view virtual returns (bool) {
    return _hasRole(SIGNER_ROLE, _signer) || _hasRole(DEFAULT_ADMIN_ROLE, _signer);
}
```

#### \_signer

El firmante para verificar la autorización. Debe ser de tipo `address`.

</Details>

<Details id="entryPoint" summary="entryPoint">

Devuelve la dirección del contrato de punto de entrada.

```solidity
function entryPoint() public view virtual override returns (IEntryPoint) {
    return entrypointContract;
}
```

</Details>

<Details id="_validatesSignature" summary="_validatesSignature">

Valida la firma de una operación de usuario.

```solidity
function _validateSignature(UserOperation calldata userOp, bytes32 userOpHash)
    internal
    virtual
    override
    returns (uint256 validationData)
{
    bytes32 hash = userOpHash.toEthSignedMessageHash();
    address signer = hash.recover(userOp.signature);

    if (!isValidSigner(signer)) return SIG_VALIDATION_FAILED;
    return 0;
}
```

</Details>

import { Details } from "@doc";
import { GithubButtonLink } from "@doc";
import { createMetadata } from "@doc";

export const metadata = createMetadata({
    image: {
        title: "Contrato ERC20SignatureMint",
        icon: "contract",
    },
    title: "ERC20SignatureMint | contratos thirdweb",
    description:
        "El contrato ERC20SignatureMint agrega la funcionalidad de la extensión de acuñación basada en firma al contrato ERC20Base",
});

# ERC20SignatureMint

El contrato inteligente `ERC20SignatureMint` agrega la [extensión de acuñación basada en firma](/contracts/build/extensions/erc-20/ERC20signaturemint) 
al contrato [ERC20Base](/contracts/build/base-contracts/erc-20/base). La [acuñación por firma](/glossary/signature-based-minting) usa [EIP-712](https://eips.ethereum.org/EIPS/eip-712), 
lo que permite que el administrador del contrato autorice la solicitud de una parte externa para acuñar tokens en el contrato del administrador. 
A un nivel alto, esto significa que puedes autorizar a otros a acuñar tokens en tu contrato y especificar exactamente qué se acuñará por esa parte externa.

```solidity
import "@thirdweb-dev/contracts/base/ERC20SignatureMint.sol";
```

<GithubButtonLink href="https://github.com/thirdweb-dev/contracts/blob/main/contracts/base/ERC20SignatureMint.sol" />

## Uso

Importa el contrato y herédalo de él.

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@thirdweb-dev/contracts/base/ERC20SignatureMint.sol";

contract MyToken is ERC20SignatureMint {
	  constructor(
        address _defaultAdmin,
        string memory _name,
        string memory _symbol,
        address _primarySaleRecipient
    )
        ERC20SignatureMint(
            _defaultAdmin,
            _name,
            _symbol,
            _primarySaleRecipient
        )
    {}
}
```

## Extensiones detectadas

Una vez desplegado, puedes utilizar las características disponibles por estas extensiones en el SDK y en el panel:

- [ERC20](/contracts/build/extensions/erc-20/ERC20)
- [ERC20Mintable](/contracts/build/extensions/erc-20/ERC20BatchMintable)
- [ERC20BatchMintable](/contracts/build/extensions/erc-20/ERC20BatchMintable)
- [ERC20SignatureMintable](/contracts/build/extensions/erc-20/ERC20signaturemint)
- [ERC20Permit](/contracts/build/extensions/erc-20/ERC20Permit)
- [PrimarySale](/contracts/build/extensions/general/PrimarySale)
- [ContractMetadata](/contracts/build/extensions/general/ContractMetadata)
- [Ownable](/contracts/build/extensions/general/Ownable)

## Funciones para sobrescribir

Las siguientes funciones han sido implementadas en este contrato y están disponibles para ser sobrescritas con lógica personalizada:

<Details id="mintWithSignature" summary="mintWithSignature">

```solidity
/**
 *  @notice           Minta tokens de acuerdo con la solicitud de menta proporcionada.
 *
 *  @param _req       El payload / solicitud de menta.
 *  @param _signature La firma producida por una cuenta que firma la solicitud de menta.
 */
function mintWithSignature(MintRequest calldata _req, bytes calldata _signature)
    external
    payable
    virtual
    returns (address signer)
{
    require(_req.quantity > 0, "Minting zero tokens.");

    // Verify and process payload.
    signer = _processRequest(_req, _signature);

    address receiver = _req.to;

    // Collect price
    _collectPriceOnClaim(_req.primarySaleRecipient, _req.quantity, _req.currency, _req.pricePerToken);

    // Mint tokens.
    _mint(receiver, _req.quantity);

    emit TokensMintedWithSignature(signer, receiver, _req);
}
```

</Details>

<Details id="_collectPriceOnClaim" summary="_collectPriceOnClaim">

```solidity
// @dev Recoge y distribuye el valor de la venta principal de los tokens que están siendo reclamados.
function _collectPriceOnClaim(
    address _primarySaleRecipient,
    uint256 _quantityToClaim,
    address _currency,
    uint256 _pricePerToken
) internal virtual {
    if (_pricePerToken == 0) {
        return;
    }

    uint256 totalPrice = (_quantityToClaim * _pricePerToken) / 1 ether;
    require(totalPrice > 0, "quantity too low");

    if (_currency == CurrencyTransferLib.NATIVE_TOKEN) {
        require(msg.value == totalPrice, "Must send total price.");
    }

    address saleRecipient = _primarySaleRecipient == address(0) ? primarySaleRecipient() : _primarySaleRecipient;
    CurrencyTransferLib.transferCurrency(_currency, msg.sender, saleRecipient, totalPrice);
}
```

</Details>

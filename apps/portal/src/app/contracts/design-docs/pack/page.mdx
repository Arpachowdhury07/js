import { DocImage } from "@doc";
import packDiagram1 from "./assets/pack-diagram-1.png";
import packDiagram2 from "./assets/pack-diagram-2.png";
import packDiagram3 from "./assets/pack-diagram-3.png";
import { createMetadata } from "@doc";

export const metadata = createMetadata({
	image: {
		title: "Documento de diseño de Pack",
		icon: "contract",
	},
	title: "Documento de diseño de Pack | thirdweb",
	description:
		"Este es un documento en vivo que explica qué es el contrato inteligente Pack de thirdweb, cómo funciona, cómo puede ser utilizado y por qué está diseñado de la manera en que está.",
});

# Documento de diseño de Pack.

Este es un documento en vivo que explica qué es el contrato inteligente `Pack` de [thirdweb](https://thirdweb.com/), cómo funciona, cómo puede ser utilizado y por qué está diseñado de la manera en que está.

El documento está escrito para lectores tanto técnicos como no técnicos. Si tienes más preguntas sobre el contrato `Pack` de thirdweb, por favor [visita nuestro sitio de soporte](https://thirdweb.com/support) o crea un issue en GitHub.

## Contexto

El contrato `Pack` de thirdweb es un mecanismo de caja de recompensas (lootbox). Una cuenta puede agrupar tokens arbitrarios ERC20, ERC721 y ERC1155 en un conjunto de packs. Un pack luego puede ser abierto a cambio de una selección de los tokens en el pack. La selección de los tokens distribuidos al abrir un pack depende de la oferta relativa de todos los tokens en los packs.

> **IMPORTANTE**: _Las funciones de Pack, como la apertura de packs, pueden ser costosas en términos de uso de gas debido a la selección aleatoria de recompensas. Por favor, revisa tus estimaciones de gas/uso, y realiza una prueba en redes de prueba antes de cualquier despliegue en mainnet._

## Producto: Cómo deberían funcionar los packs (sin terminología web3)

Supongamos que queremos crear un conjunto de packs con tres tipos de recompensas: 80 **círculos**, 15 **cuadrados**, y 5 **estrellas**, y queremos que exactamente 1 recompensa sea distribuida cuando se abra un pack.

En este caso, con el contrato `Pack` de thirdweb, cada pack garantiza entregar exactamente 1 recompensa. Para cumplir con esta garantía, el número de packs creados es igual a la suma de las existencias de cada recompensa. Así que ahora tenemos `80 + 15 + 5`, es decir, `100` packs disponibles.

<DocImage src={packDiagram1} className="w-80" />

Al abrir uno de estos 100 packs, el abridor recibirá una de las recompensas del pack: ya sea un **círculo**, un **cuadrado** o una **estrella**. Las probabilidades de recibir una recompensa particular dependen de cuántas de esa recompensa existan en el conjunto de packs.

El porcentaje de probabilidad de recibir un tipo particular de recompensa (por ejemplo, una **estrella**) al abrir un pack se calcula como: `(número_de_estrellas_en_pack) / (número_total_de_packs)`

Al principio, existen 80 **círculos**, 15 **cuadrados** y 5 **estrellas** en nuestro conjunto de 100 packs. Esto significa que las probabilidades de recibir un **círculo** al abrir un pack son `80/100`, es decir, un 80%. De manera similar, el abridor del pack tiene un 15% de probabilidad de recibir un **cuadrado**, y un 5% de probabilidad de recibir una **estrella** al abrir un pack.

<DocImage src={packDiagram2} className="w-96" />

Las probabilidades de recibir cada tipo de recompensa cambian a medida que se abren los packs. Supongamos que uno de nuestros 100 packs se abre y se recibe un **círculo**. Ahora tenemos 99 packs restantes, con _79_ **círculos**, 15 **cuadrados** y 5 **estrellas**.

Para el siguiente pack que se abra, el abridor tendrá una probabilidad de `79/99`, es decir, alrededor de un 79.8% de recibir un **círculo**, alrededor de un 15.2% de recibir un **cuadrado**, y alrededor de un 5.1% de recibir una **estrella**.

### Partes clave de `Pack` como producto

Dada la ilustración anterior de 'cómo deberían funcionar los packs', ahora podemos anotar algunas partes clave del producto `Pack`, que cualquier implementación de `Pack` debería mantener:

- Un creador puede agrupar tokens arbitrarios ERC20, ERC721 y ERC1155 en un conjunto de packs.
- El porcentaje de probabilidad de recibir una recompensa particular al abrir un pack debe ser una función de la oferta relativa de las recompensas dentro de un pack. Es decir, abrir un pack _no debe_ ser como una lotería, donde hay un porcentaje inmutable de probabilidad de distribución asignado a recompensas en un conjunto de packs.
- Un abridor de pack _no debe_ poder saber de antemano qué recompensa recibirá al abrir un pack.
- Cada pack en un conjunto de packs puede ser abierto cuando el respectivo propietario del pack decida abrirlo.
- Los packs deben ser capaces de ser transferidos y vendidos en un mercado.

## Por qué estamos construyendo `Pack`

Los packs están diseñados para funcionar como packs genéricos que contienen recompensas, donde un pack puede ser abierto para recuperar las recompensas dentro de ese pack.

Packs como estos ya existen, por ejemplo, en packs regulares de [cartas de Pokemon](https://www.pokemoncenter.com/category/booster-packs), o en otras formas que utilizan tecnología blockchain, como los packs de [NBA Topshot](https://nbatopshot.com/). Este concepto es ubicuo en varias culturas, sectores y productos.

A medida que los tokens continúan siendo legitimados como activos/artículos, estamos llevando los 'packs' — una forma histórica de gamificar la distribución de artículos — a la cadena, como un primitivo con una implementación robusta que se puede utilizar en todas las cadenas y para todo tipo de casos de uso.

## Detalles técnicos

Ahora repasaremos los detalles técnicos del contrato `Pack`, con referencias al ejemplo dado en la sección anterior — 'Cómo funcionan los packs (sin terminología web3)'.

### ¿Qué se puede agrupar en los packs?

Puedes crear un conjunto de packs con cualquier combinación de cualquier número de tokens ERC20, ERC721 y ERC1155. Por ejemplo, puedes crear un conjunto de packs con 10,000 [USDC](https://www.circle.com/en/usdc) (ERC20), 1 [Bored Ape Yacht Club](https://opensea.io/collection/boredapeyachtclub) NFT (ERC721), y 50 de [el primer NFT de adidas originals](https://opensea.io/assets/0x28472a58a490c5e09a238847f66a68a47cc76f0f/0) (ERC1155).

Con tokens estrictamente no fungibles, es decir, NFTs ERC721, cada NFT tiene una oferta de 1. Esto significa que si se abre un pack y el contrato `Pack` selecciona un NFT ERC721 para ser distribuido al abridor, ese 1 NFT será distribuido al abridor.

Con tokens fungibles (ERC20) y semi-fungibles (ERC1155), debes especificar cuántos de esos tokens deben ser distribuidos al abrir un pack, como unidad. Por ejemplo, si agregas 10,000 USDC a un pack, puedes especificar que 20 USDC, como unidad, deben ser distribuidos al abrir un pack. Esto significa que estás agregando 500 unidades de 20 USDC al conjunto de packs que estás creando.

Entonces, lo que se puede agrupar en los packs son _n_ configuraciones de tipo '500 unidades de 20 USDC'. Estas configuraciones son interpretadas por el contrato `Pack` como `PackContent`:

```solidity
enum TokenType { ERC20, ERC721, ERC1155 }

struct Token {
    address assetContract;
    TokenType tokenType;
    uint256 tokenId;
    uint256 totalAmount;
}

uint256 perUnitAmount;
```

| Valor         | Descripción                                                                                                                                                             |
| ------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| assetContract | La dirección del contrato del token.                                                                                                                                     |
| tokenType     | El tipo de token -- ERC20 / ERC721 / ERC1155                                                                                                                            |
| tokenId       | El tokenId del token. (No aplicable para tokens ERC20. El contrato ignorará este valor para tokens ERC20.)                                                              |
| totalAmount   | La cantidad total de este token agrupado en el pack. (No aplicable para tokens ERC721. El contrato siempre considerará esto como 1 para tokens ERC721.)                  |
| perUnitAmount | La cantidad de este token a distribuir como unidad al abrir un pack. (No aplicable para tokens ERC721. El contrato siempre considerará esto como 1 para tokens ERC721.) |

**Nota:** Un pack puede contener diferentes configuraciones para el mismo token. Por ejemplo, el mismo conjunto de packs puede contener '500 unidades de 20 USDC' y '10 unidades de 1000 USDC' como dos tipos independientes de recompensas subyacentes.

## Creación de packs

Puedes crear packs con cualquier token ERC20, ERC721 o ERC1155 que poseas. Para crear packs, debes especificar lo siguiente:

```solidity
/// @dev Creates a pack with the stated contents.
function createPack(
    Token[] calldata contents,
    uint256[] calldata numOfRewardUnits,
    string calldata packUri,
    uint128 openStartTimestamp,
    uint128 amountDistributedPerOpen,
    address recipient
) external
```

| Parámetro               | Descripción                                                                                                    |
| ----------------------- | -------------------------------------------------------------------------------------------------------------- |
| contents                | Tokens/activos agrupados en el conjunto de packs.                                                              |
| numOfRewardUnits        | Número de unidades de recompensa para cada activo, donde cada unidad de recompensa contiene la cantidad por unidad del activo correspondiente. |
| packUri                 | La URI (metadatos) asignada a los packs creados.                                                                |
| openStartTimestamp      | La marca de tiempo después de la cual se pueden abrir los packs.                                                 |
| amountDistributedPerOpen| El número de unidades de recompensa distribuidas por cada apertura.                                             |
| recipient               | El destinatario de los packs creados.                                                                           |

### Los packs son tokens ERC1155, es decir, NFTs

Los packs en sí mismos son tokens ERC1155. Por lo tanto, un conjunto de packs creado con tus tokens se identifica mediante un tokenId único, tiene una URI de metadatos asociada y una oferta variable.

En el ejemplo dado en la sección anterior — 'Resumen no técnico', hay un conjunto de 100 packs creados, donde ese conjunto completo de packs se identifica con un tokenId único.

Dado que los packs son tokens ERC1155, puedes publicar múltiples conjuntos de packs utilizando el mismo contrato `Pack`.

### Oferta de packs

Al crear packs, puedes especificar el número de unidades de recompensa que se distribuirán al abridor al abrir un pack. Así, al crear un conjunto de packs, el número total de packs en ese conjunto se calcula como:

`total_supply_of_packs = (total_reward_units) / (reward_units_to_distribute_per_open)`

Esto garantiza que cada pack pueda ser abierto para recuperar las unidades de recompensa _n_ previstas dentro del conjunto de packs.

## Actualización de packs

Puedes agregar más contenidos a un pack creado, hasta la primera transferencia de los packs. No se pueden hacer adiciones después de eso.

```solidity
/// @dev Add contents to an existing packId.
function addPackContents(
    uint256 packId,
    Token[] calldata contents,
    uint256[] calldata numOfRewardUnits,
    address recipient
) external
```

| Parámetro        | Descripción                                                                                                    |
| ---------------- | -------------------------------------------------------------------------------------------------------------- |
| PackId           | El identificador del pack al que agregar contenidos.                                                            |
| contents         | Tokens/activos agrupados en el conjunto de packs.                                                              |
| numOfRewardUnits | Número de unidades de recompensa para cada activo, donde cada unidad de recompensa contiene la cantidad por unidad del activo correspondiente. |
| recipient        | El destinatario del nuevo suministro agregado. Debe ser la misma dirección utilizada durante la creación de los packs. |

## Abrir packs

Los packs pueden ser abiertos por los propietarios de los packs. Un propietario de un pack puede abrir múltiples packs a la vez. 'Abrir un pack' esencialmente significa quemar el pack y recibir el número _n_ de unidades de recompensa desde el interior del conjunto de packs, a cambio.

```solidity
function openPack(uint256 packId, uint256 amountToOpen) external;

```

| Parámetro    | Descripción                          |
| ------------ | ------------------------------------ |
| packId       | El identificador del pack a abrir.   |
| amountToOpen | El número de packs a abrir a la vez. |

### Cómo se seleccionan las unidades de recompensa para distribuir al abrir packs

Nos basamos en el ejemplo de la sección anterior — 'Resumen no técnico'.

Cada **cuadrado**, **círculo** o **estrella** se considera una 'unidad de recompensa'. Por ejemplo, las 5 **estrellas** en los packs pueden ser “5 unidades de 1000 USDC”, lo cual está representado en el contrato `Pack` por la siguiente información

```solidity
struct Token {
    address assetContract; // USDC address
    TokenType tokenType; // TokenType.ERC20
    uint256 tokenId; // Not applicable
    uint256 totalAmount; // 5000
}

uint256 perUnitAmount; // 1000
```

La probabilidad porcentual de recibir un tipo particular de recompensa (por ejemplo, una **estrella**) al abrir un pack se calcula como: `(número_de_estrellas_en_pack) / (número_total_de_packs)`. Aquí, `número_de_estrellas_en_pack` se refiere al número total de unidades de recompensa del tipo **estrella** dentro del conjunto de packs, por ejemplo, un total de 5 unidades de 1000 USDC.

Volviendo al ejemplo de la sección anterior — 'Resumen no técnico'. — la oferta de unidades de recompensa en el conjunto relevante de packs — 80 **círculos**, 15 **cuadrados** y 5 **estrellas** — se puede representar en una línea numérica, desde cero hasta la oferta total de packs, en este caso, 100.

<DocImage src={packDiagram2} className="w-96" />

Cada vez que se abre un pack, el contrato `Pack` usa un nuevo número _aleatorio_ en el rango de la oferta total de packs para determinar qué unidad de recompensa será distribuida al abridor del pack.

En nuestro caso de ejemplo, el contrato `Pack` usa un número aleatorio menor a 100 para determinar si el abridor del pack recibirá un **círculo**, un **cuadrado** o una **estrella**.

Entonces, por ejemplo, si el número aleatorio `num` es tal que `0 <= num < 5`, el abridor del pack recibirá una **estrella**. De manera similar, si `5 <= num < 20`, el abridor recibirá un **cuadrado**, y si `20 <= num < 100`, el abridor recibirá un **círculo**.

Ten en cuenta que, dado este diseño, el abridor realmente tiene un 5% de probabilidad de recibir una **estrella**, un 15% de probabilidad de recibir un **cuadrado**, y un 80% de probabilidad de recibir un **círculo**, siempre que el número aleatorio utilizado en la selección de la unidad de recompensa a distribuir sea realmente aleatorio.

## El problema con los números aleatorios

De la sección anterior — 'Cómo se seleccionan las unidades de recompensa para distribuir al abrir packs':

> Ten en cuenta que, dado este diseño, el abridor realmente tiene un 5% de probabilidad de recibir una **estrella**, un 15% de probabilidad de recibir un **cuadrado**, y un 80% de probabilidad de recibir un **círculo**, siempre que el número aleatorio utilizado en la selección de la unidad de recompensa a distribuir sea realmente aleatorio.

En el caso de la apertura de un pack, el número aleatorio utilizado en el proceso afecta qué unidad de recompensa selecciona el contrato `Pack` para ser distribuida al propietario del pack.

Si un propietario de pack puede predecir, en cualquier momento, qué número aleatorio se usará en este proceso de selección de la unidad de recompensa para distribuir al abrir un pack en ese momento, el propietario del pack podrá abrir su pack en un momento donde recibirá la recompensa que desea del pack.

Esta es una **posible** **vulnerabilidad crítica** ya que una característica central de la oferta del producto `Pack` es la garantía de que cada unidad de recompensa en un pack tiene una probabilidad % de ser distribuida al abrir un pack, y que esta probabilidad tiene cierta integridad (en el sentido común). Poder predecir los números aleatorios, como se describió anteriormente, anula esta garantía.

### Obtención de números aleatorios — solución

El contrato `Pack` requiere un diseño en el que un propietario de pack _no pueda predecir_ el número aleatorio que se usará en el proceso de apertura de su pack.

Para garantizar lo anterior, realizamos una simple verificación en la función `openPack`:

```solidity
require(isTrustedForwarder(msg.sender) || _msgSender() == tx.origin, "opener cannot be smart contract");
```

`tx.origin` devuelve la dirección de la cuenta externa que inició la transacción, de la cual la llamada a la función `openPack` es parte.

La verificación anterior esencialmente significa que solo una cuenta externa, es decir, una billetera de usuario final, y no un contrato inteligente, puede abrir packs. Esto nos permite generar un número pseudoaleatorio utilizando variables de bloque, con el propósito de `openPack`:

```solidity
uint256 random = uint256(keccak256(abi.encodePacked(_msgSender(), blockhash(block.number - 1), block.difficulty)));
```

Dado que solo las billeteras de usuario final pueden abrir packs, un propietario de pack _no puede predecir_ el número aleatorio que se utilizará en el proceso de apertura de su pack. Esto se debe a que el abridor de un pack no puede consultar el resultado del cálculo del número aleatorio durante un bloque determinado y llamar a `openPack` dentro de ese mismo bloque.

Ahora listamos la ventaja más importante, y el consecuente sacrificio de usar esta solución:

| Ventaja                                                                                                          | Sacrificio                                                                    |
| ---------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------- |
| Un propietario de pack no puede predecir el número aleatorio que se utilizará en el proceso de apertura de su pack. | Solo las cuentas externas / EOAs pueden abrir packs. Los contratos inteligentes no pueden abrir packs. |

### Obtención de números aleatorios — soluciones descartadas

Ahora discutiremos algunas posibles soluciones para este problema de diseño junto con sus sacrificios / por qué no usamos estas soluciones:

- **Usando un oráculo (por ejemplo, Chainlink VRF)**

  Usar un oráculo como Chainlink VRF permite el diseño original para el contrato `Pack`: un propietario de pack puede abrir _n_ packs, cuando quiera, independientemente de cuándo los otros propietarios de packs elijan abrir sus propios packs. En resumen, abrir _n_ packs se convierte en un evento aislado realizado por un solo propietario de pack.

  <DocImage src={packDiagram3} className="w-[450px]" />

  **Por qué no estamos usando esta solución:**

  - Chainlink VRF v1 solo está disponible en Ethereum y Polygon, y Chainlink VRF v2 (versión actual) solo está disponible en Ethereum y Binance. Como resultado, esta solución no puede usarse por sí sola en todas las cadenas que thirdweb soporta (y quiere soportar).
  - Cada solicitud de número aleatorio cuesta al usuario final el token LINK de Chainlink — es costoso y parece un requisito aleatorio para usar una oferta de thirdweb.

- **Aleatoriedad de revelación retardada: recompensas para todos los packs en un conjunto de packs visibles de una sola vez**

  Por 'revelación retardada' nos referimos a lo siguiente:
  - Al crear un conjunto de packs, el creador proporciona (1) una semilla cifrada, es decir, un número entero (consulta el [patrón de cifrado usado en los NFTs de revelación retardada de thirdweb](https://blog.thirdweb.com/delayed-reveal-nfts#step-1-encryption)), y (2) un número de bloque futuro.
  - Los packs creados son _no transferibles_ por ninguna dirección excepto (1) el creador del pack, o (2) direcciones aprobadas manualmente por el creador del pack. Esto permite que el creador distribuya los packs como desee, _y_ es esencial para el siguiente paso.
  - Después de que pase el número de bloque futuro especificado, el creador envía la semilla no cifrada al contrato `Pack`. Cada vez que un propietario de pack abre un pack, calculamos el número aleatorio que se usará en el proceso de apertura de la siguiente manera:
    ```solidity
    uint256 random = uint(keccak256(seed, msg.sender, blockhash(storedBlockNumber)));
    ```
    - Nadie puede predecir el hash del bloque del bloque futuro almacenado a menos que el creador del pack sea el minero del bloque con ese número de bloque (altamente improbable).
    - La semilla es controlada por el creador, enviada en el momento de la creación del pack, y no puede ser cambiada después de la presentación.
    - Dado que los packs no son transferibles de la manera descrita anteriormente, mientras el abridor del pack no esté aprobado para transferir packs, el abridor no puede manipular el valor de `random` transfiriendo packs a una dirección deseable y luego abriendo el pack desde esa dirección.
      
      **Por qué no estamos usando esta solución:**
  - Involucramiento activo del creador del pack. Se confía en ellos para revelar la semilla no cifrada una vez que los packs sean elegibles para ser abiertos.
  - Los packs _deben_ ser no transferibles de la manera descrita anteriormente, lo que significa que no se pueden comprar en un mercado, etc. Falta un mecanismo de distribución incorporado para los packs.

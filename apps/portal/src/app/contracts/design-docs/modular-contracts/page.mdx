import { DocImage, Callout } from "@doc";
import { createMetadata } from "@doc";
import modularContractsAnalogyImage from "./assets/modular-contracts-analogy.png";
import modularContractsFlowImage from "./assets/modular-contracts-flow.png";

export const metadata = createMetadata({
	image: {
		title: "Documento de diseño de Contratos Modulares",
		icon: "contract",
	},
	title: "Documento de diseño de Contratos Modulares | thirdweb",
	description:
		"Este es un documento en vivo que explica los detalles técnicos del diseño de la arquitectura de Contratos Modulares",
});

# Documento de diseño de Contratos Modulares.

## Contexto

_Modular Contracts_ es un marco para escribir contratos inteligentes altamente composables. Estos son contratos inteligentes en los que puedes agregar, eliminar, actualizar o cambiar las partes exactas que desees.

Un contrato modular está compuesto por dos tipos de contratos:

1. Contrato **Core**: la API fundamental que se puede personalizar instalando Extensiones.
2. Contrato **Extension**: implementa un conjunto de funcionalidades que se habilitan en un Core cuando se instala.

<Callout variant="info">
	Como analogía, piensa en el robot a continuación. El torso es el *Core* al que
	puedes conectar/desconectar las *Extensiones*. 
    
    El torso tiene una forma particular y expone enchufes en lugares fijos, todos los cuales determinan cómo se adjuntarán las extensiones. De manera similar,
    un contrato inteligente Core tiene una API fija que determina qué Extensiones son compatibles para la instalación.

    Las *Extensiones* en sí mismas, como una pierna, un brazo, una cabeza, etc., dan al robot (es decir, al contrato modular en su conjunto) sus diversas capacidades.

    <DocImage src={modularContractsAnalogyImage} className="w-[500px]" />

</Callout>


Instalar una Extensión en un Core personaliza el comportamiento del Core de dos maneras:

1. Nuevas funciones se pueden llamar en el contrato Core (a través de su [función de fallback](https://docs.soliditylang.org/en/v0.8.26/contracts.html#fallback-function)).
2. Las funciones fijas del contrato Core hacen llamadas a funciones de retorno en la Extensión.

<DocImage src={modularContractsFlowImage} />

Como ejemplo, un desarrollador puede escribir un contrato inteligente ERC-721 de NFT como un contrato **_Core_**. Un ecosistema completo de personalizaciones creadas por terceros puede formarse alrededor de este **_Core_**.

Mecanismos de acuñación y quema, formatos de metadatos de tokens, capacidades soulbound, etc., pueden implementarse como contratos inteligentes **_Extension_** independientes que se pueden conectar al contrato ERC-721 **_Core_** de un desarrollador.

Esto significa que los desarrolladores pueden ahora desplegar este contrato ERC-721 **_Core_**, y acceder a una serie de personalizaciones que pueden usar para hacer evolucionar su colección de NFT con el tiempo.

Como se ve en este ejemplo, la ventaja de construir un producto con Contratos Modulares es:

1. **A prueba de futuro:** un producto tiene necesidades que evolucionan con el tiempo. Los contratos modulares pueden actualizarse para adaptarse a los cambios en los requisitos del producto y a las nuevas innovaciones de la industria según sea necesario.
2. **Flexible:** el marco de Contratos Modulares es compatible con todos los estándares de actualización y características de la industria. Esto significa que los contratos modulares pueden escribirse para seguir cualquiera de los EIPs populares y estructurarse como contratos actualizables o no actualizables, todo sin perder su capacidad de personalización.
3. **Altamente personalizable:** los Contratos Modulares se han desarrollado para disfrutar de una vasta biblioteca de personalizaciones opcionales en las que puedes descubrir las características de contrato inteligente adecuadas para desarrollar tu caso de uso.

## Diseño Técnico

### Resumen

Esta arquitectura estandariza cómo un contrato router verifica que un contrato de implementación sea seguro y compatible como un destino de llamada para un conjunto dado de funciones.

La arquitectura describe interfaces para contratos router y contratos de implementación que les permiten comunicarse y acordar sobre la compatibilidad entre ellos, e interfaces para el cumplimiento de ERC-165 por parte de los contratos router.

### Motivación

Los contratos router (es decir, contratos con un destino de llamada potencialmente diferente por función) han ganado adopción debido a su calidad de ser a prueba de futuro y actualizables por partes.

Existen varias formas diferentes de escribir contratos router o de implementación, lo que significa que usar cualquier contrato de implementación dado como destino de llamada en cualquier contrato router puede llevar a que uno de los contratos no opere de acuerdo con su especificación.

El objetivo de esta arquitectura es hacer que todos los contratos router y de implementación sean interoperables creando un método donde ambos contratos se comuniquen y acuerden sobre la compatibilidad antes de que un router establezca algún contrato de implementación como el destino de llamada para un conjunto de funciones.

El ecosistema se beneficia de esta estandarización ya que:

- Los desarrolladores pueden reutilizar de forma segura cualquier característica desarrollada por ellos mismos o por terceros (contratos de implementación) a través de muchos proyectos (contratos router).
- Las nuevas innovaciones de características (contratos de implementación) pueden romper explícitamente la compatibilidad con proyectos antiguos ya desplegados (contratos router).

### Especificación

> Las palabras clave "DEBE", "NO DEBE", "REQUERIDO", "DEBERÍA", "NO DEBERÍA", "RECOMENDADO", "NO RECOMENDADO", "PUEDO", y "OPCIONAL" en este documento deben interpretarse según lo descrito en RFC 2119 y RFC 8174.

#### Definiciones

- **Router**: un contrato inteligente con un destino de llamada potencialmente diferente por función
- **Implementación**: un contrato inteligente almacenado por un contrato router como el destino de llamada para un conjunto dado de funciones.
- **Modular Core:** un contrato router escrito en la arquitectura de Contratos Modulares y que expresa compatibilidad con ciertos contratos de implementación. También se refiere como “Core”.
- **Modular Extension**: un contrato de implementación escrito en la arquitectura de Contratos Modulares y que expresa compatibilidad con ciertos contratos router. También se refiere como “Extension”.

#### Configuración de la Extensión

La estructura `ExtensionConfig` contiene toda la información que un Core usa para verificar si una Extension es compatible para su instalación.

**Estructura `ExtensionConfig`**

| Campo                        | Tipo               | Descripción                                                                                                                           |
| ---------------------------- | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------- |
| requiredInterfaces           | bytes4[]           | Las interfaces ERC-165 que un Core DEBE soportar para ser compatible para la instalación. (Campo OPCIONAL)                            |
| registerInstallationCallback | bool               | Si la Extension espera llamadas a las funciones de callback onInstall y onUninstall en los momentos de instalación y desinstalación, respectivamente |
| supportedInterfaces          | bytes4[]           | Las interfaces ERC-165 que un Core soporta al instalar la Extension.                                                                  |
| callbackFunctions            | CallbackFunction[] | Lista de funciones de callback que el Core DEBE llamar en algún punto durante la ejecución de sus funciones fijas.                    |
| fallbackFunction             | FallbackFunction[] | Lista de funciones que el Core DEBE llamar a través de su función fallback con la Extension como el destino de llamada.               |

**Estructura `FallbackFunction`**

| Campo          | Tipo    | Descripción                                                                                                                           |
| -------------- | ------- | ------------------------------------------------------------------------------------------------------------------------------------- |
| selector       | bytes4  | El selector de 4 bytes de la función.                                                                                                 |
| permissionBits | uint256 | La función fallback del Core DEBE verificar que msg.sender tenga estos permisos antes de realizar una llamada en la Extension. (Campo OPCIONAL) |

**Estructura `CallbackFunction`**

| Campo    | Tipo   | Descripción                          |
| -------- | ------ | ------------------------------------ |
| selector | bytes4 | El selector de 4 bytes de la función. |

#### Modular Core

Un contrato router DEBE implementar `IModularCore` y las interfaces ERC-165 para cumplir con la arquitectura de Contratos Modulares.

La función `ERC165.supportsInterface` DEBE devolver verdadero para todas las interfaces soportadas por el Core y las interfaces soportadas expresadas en el ExtensionConfig de las extensiones instaladas.

```solidity
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.23;

import {IExtensionConfig} from "./IExtensionConfig.sol";
import {IERC165} from "./IERC165.sol";

interface IModularCore is IExtensionConfig, IERC165 {
    /*//////////////////////////////////////////////////////////////
                            STRUCTS & ENUMS
    //////////////////////////////////////////////////////////////*/

    /**
    *  @dev Indica si la ejecución revierte cuando la función de callback no está implementada por ninguna extensión instalada.
    *  @param OPCIONAL La ejecución no revierte cuando la función de callback no está implementada.
    *  @param REQUERIDO La ejecución revierte cuando la función de callback no está implementada.
    */
    enum CallbackMode {
        OPTIONAL,
        REQUIRED
    }

    /**
    *  @dev Estructura que representa una función de callback llamada en una Extensión durante la ejecución de alguna función fija.
    *  @param selector El selector de función de 4 bytes de la función de callback.
    *  @param mode Indica si la ejecución revierte cuando la función de callback no está implementada por ninguna Extensión instalada.
    */
    struct SupportedCallbackFunction {
        bytes4 selector;
        CallbackMode mode;
    }

    /**
    *  @dev Estructura que representa una Extensión instalada.
    *  @param implementation La dirección del contrato de la Extensión.
    *  @param config La configuración de la Extensión del contrato de la Extensión.
    */
    struct InstalledExtension {
        address implementation;
        ExtensionConfig config;
    }

    /*//////////////////////////////////////////////////////////////
                            VIEW FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /// @dev Devuelve todas las llamadas a las funciones de devolución de llamada realizadas a las Extensiones en algún momento durante la ejecución de una función fija.
function getSupportedCallbackFunctions() external pure returns (SupportedCallbackFunction[] memory);

/// @dev Devuelve todas las extensiones instaladas y sus respectivas configuraciones de extensión.
function getInstalledExtensions() external view returns (InstalledExtension[] memory);

    /*//////////////////////////////////////////////////////////////
                            EXTERNAL FUNCTIONS
    //////////////////////////////////////////////////////////////*/

    /**
    *  @dev Instala una Extensión en el Core.
    *
    *  @param extensionContract La dirección del contrato de Extensión que se va a instalar.
    *  @param data Los datos que se pasarán a la función de devolución de llamada onInstall de la Extensión.
    *
    *  DEBE implementar el control de autorización.
    *  DEBE llamar a la función de devolución de llamada `onInstall` si la Configuración de Extensión ha registrado las devoluciones de llamada de instalación.
    *  DEBE revertir si el Core no implementa la interfaz requerida por la Extensión, especificada en la Configuración de Extensión.
    *  DEBE revertir si alguna función de devolución de llamada o función de fallback en la Configuración de Extensión de la Extensión ya está registrada en el Core con otra Extensión.
    *
    *  PUEDE interpretar la dirección proporcionada como la dirección de implementación del contrato de Extensión para instalarlo como un proxy.
    */
    function installExtension(address extensionContract, bytes calldata data) external payable;

    /**
    *  @dev Desinstala una Extensión del Core.
    *
    *  @param extensionContract La dirección del contrato de Extensión que se va a desinstalar.
    *  @param data Los datos que se pasarán a la función de devolución de llamada onUninstall de la Extensión.
    *
    *  DEBE implementar el control de autorización.
    *  DEBE llamar a la función de devolución de llamada `onUninstall` si la Configuración de Extensión ha registrado las devoluciones de llamada de instalación.
    *
    *  PUEDE interpretar la dirección proporcionada como la dirección de implementación del contrato de Extensión que está instalado como un proxy.
    */

    function uninstallExtension(address extensionContract, bytes calldata data) external payable;
}
```

#### Extensión Modular

Cualquier función de devolución de llamada (callback) en la ExtensionConfig de una Extensión instalada DEBE ser llamada por el Core durante la ejecución de alguna función fija.

Cualquier función de fallback en la ExtensionConfig de una Extensión instalada DEBE ser llamada por el Core a través de su fallback, cuando sea llamada con los datos de entrada (calldata) de la función de fallback dada.

```solidity
interface IModularExtension is IExtensionConfig {
    /**
     *  @dev Returns the ExtensionConfig of the Extension contract.
     */
    function getExtensionConfig() external pure returns (ExtensionConfig memory);
}
```

### Razonamiento

#### Funciones de Callback y Fallback

Permite que un Core sea personalizado por contratos de Extensiones de dos formas diferentes: funciones de callback y funciones de fallback.

Las funciones de callback son llamadas a funciones realizadas a una Extensión en algún punto durante la ejecución de una función fija. Permiten inyectar lógica personalizada dentro de las funciones fijas de un Core. Esto significa que un Core puede tener una API fundamental de funciones fijas que, sin embargo, puede disfrutar de personalizaciones.

Las funciones de fallback son funciones que se pueden llamar en el Core como un punto de entrada, donde el Core llama a una Extensión desde su función de fallback con los datos de entrada (calldata) que recibe. Permiten agregar funcionalidades a la API fundamental de un Core.

#### Las funciones de Callback y Fallback se llaman a través de `delegateCall`

Todas las funciones de callback y fallback se llaman realizando un `delegateCall` al contrato de la Extensión donde la función respectiva está definida. Esto significa que los contratos de Extensión definen funciones que indican al contrato Core cómo debe actualizar su estado.

Esto permite a los desarrolladores preocuparse solo por la dirección de un contrato core como punto de entrada para llamar a cualquier función, y para que el estado que constituye todo el sistema del contrato inteligente no se divida entre el Core y varios contratos de Extensión, sino que se consolide únicamente en el estado del contrato Core.

#### Compatibilidad entre Core y Extensiones

Una Extensión es compatible para instalar en un Core si:

1. todas las funciones de callback de la Extensión (especificadas en `ExtensionConfig`) están incluidas en los callbacks soportados del Core (especificados en `IModularCore.getSupportedCallbackFunctions`).

   Esto se debe a que asumimos que una Extensión solo especifica una función de callback en su `ExtensionConfig` cuando espera que el Core la llame.

2. el Core implementa la interfaz requerida (si la hay) especificada en el `ExtensionConfig`.

   Es opcional que un `ExtensionConfig` especifique una interfaz que un Core debe implementar. Sin embargo, algunas Extensiones solo pueden tener sentido para ser instaladas en contratos Core particulares, y el campo `requiredInterfaceId` de `ExtensionConfig` codifica este requisito.

#### Funciones getter puras

Tanto `IModularCore.getSupportedCallbackFunctions` como `IModularExtension.getExtensionConfig` son funciones puras, lo que significa que su valor de retorno no cambia en función de ningún almacenamiento.

Para una Extensión dada, es importante que la representación almacenada del `ExtensionConfig` en el Core no quede desincronizada con el valor de retorno real de `IModularExtension.getExtensionConfig` en ningún momento, ya que esto podría llevar a consecuencias no deseadas, como que el Core llame a funciones de la Extensión que ya no existen o que no se deben llamar en el contrato de Extensión.

#### Permisos en las estructuras `FallbackFunction` y `CallbackFunction`

La estructura `FallbackFunction` contiene un campo `uint256 permissions` que permite expresar los permisos requeridos por el `msg.sender` en el fallback del contrato Core para estar autorizado a llamar la función relevante en el contrato de la Extensión.

Esto es importante porque un llamante debe estar autorizado para realizar las actualizaciones del estado del contrato Core que resultarán de un `delegateCall` a la función correspondiente en el contrato de la Extensión.

La estructura `CallbackFunction` no contiene un campo similar de permisos.

Esto es porque una llamada a función de callback se especifica en el cuerpo de la función fija, y por lo tanto, la autorización del llamante recae en el contrato Core mismo, ya que se espera que el Core realice las comprobaciones de autorización sobre los llamantes en sus funciones fijas, cuando sea necesario.

### Implementación de Referencia

#### `IModularCore`

https://github.com/thirdweb-dev/modular-contracts/blob/main/src/ModularCore.sol

#### IModularExtension

```solidity
library MockExtensionStorage {
    /// @custom:storage-location erc7201:mock.extension
    bytes32 public constant MOCK_EXTENSION_STORAGE_POSITION =
        keccak256(abi.encode(uint256(keccak256("mock.extension")) - 1)) & ~bytes32(uint256(0xff));

    struct Data {
				uint256 count;
    }

    function data() internal pure returns (Data storage data_) {
        bytes32 position = MOCK_EXTENSION_STORAGE_POSITION;
        assembly {
            data_.slot := position
        }
    }
}

contract MockExtension is IModularExtension {

    function increment() external {
			   MockExtensionStorage.data().count++;
    }

    function getIndex() external view {
		    return MockExtensionStorage.data().count++;
    }

    function getExtensionConfig() external pure override returns (ExtensionConfig memory config) {
        config.callbackFunctions = new CallbackFunction[](1);
        config.callbackFunctions[0] = CallbackFunction(this.increment.selector);

        config.fallbackFunctions = new FallbackFunction()[1];
        config.fallbackFunctions[0] = FallbackFunction(this.getIndex.selector, 0);
    }
}
```

### Consideraciones de seguridad

#### Desincronización del Core con la Extensión

Para que un Core quede “desincronizado” con una Extensión instalada significa que la configuración de la extensión almacenada localmente por el Core es diferente al valor de retorno de la función `getExtensionConfig` de la Extensión.

Dado que la configuración de la extensión de una Extensión codifica la especificación que define cómo se debe usar el contrato de la Extensión cuando se instala, un Core desincronizado con una Extensión instalada de esta manera es una ruptura de la especificación tanto para el Core como para los contratos de la Extensión.

Este escenario puede ocurrir cuando el valor de retorno de la función `getExtensionConfig` cambia después y mientras la Extensión está instalada en el Core. Dado que `getExtensionConfig` es una función pura, esto solo es posible cuando la Extensión instalada es un contrato proxy cuya implementación subyacente puede actualizarse, y por lo tanto, el valor de retorno de la función pura `getExtensionConfig` puede cambiar potencialmente.

Por esta razón, recomendamos no usar contratos proxy ya existentes como Extensiones para instalar, y en su lugar, instalar Extensiones que sean contratos de implementación no proxy.

Una actualización/parche a una Extensión instalada debe realizarse primero desinstalando la Extensión y luego reinstalando la Extensión proporcionando la dirección de implementación nueva al función `installExtension`.


---

thirdweb está emocionado de traer los Contratos Modulares a los desarrolladores. El marco de Contratos Modulares está siendo desarrollado activamente en el repositorio de código abierto thirdweb-dev/modular-contracts en GitHub, y actualmente está en auditoría.

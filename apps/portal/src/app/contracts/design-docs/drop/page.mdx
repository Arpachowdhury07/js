import { DocImage } from "@doc";
import claimConditionsImage from "./assets/claim-conditions.png";
import { createMetadata } from "@doc";

export const metadata = createMetadata({
	image: {
		title: "Documento de diseño del contrato Drop",
		icon: "contract",
	},
	title: "Documento de diseño del contrato Drop | thirdweb",
	description:
		"Este es un documento en vivo que explica qué son los contratos inteligentes Drop de thirdweb, cómo funcionan, cómo se pueden usar y por qué están escritos de la manera en que están.",
});

# Documento de diseño de Drop.

Este es un documento en vivo que explica qué son los contratos inteligentes `Drop` de [thirdweb](https://thirdweb.com/), cómo funcionan, cómo se pueden usar y por qué están escritos de la manera en que están.

El documento está dirigido a lectores tanto técnicos como no técnicos. Para realizar más preguntas sobre cualquiera de los contratos `Drop` de thirdweb, por favor [visita nuestro sitio de soporte](https://thirdweb.com/support) o crea un problema en GitHub.

## Contexto

Los contratos `Drop` de thirdweb son mecanismos de distribución de tokens. Este mecanismo de distribución está disponible para tokens ERC20, ERC721 y ERC1155, como `DropERC20`, `DropERC721` y `DropERC1155`.

Los contratos `Drop` están destinados a ser utilizados cuando el objetivo del creador del contrato es que una audiencia venga y reclame tokens dentro de ciertas restricciones, por ejemplo: "solo las direcciones en una lista de permitidos pueden acuñar tokens", o "los minters deben pagar _x_ cantidad en _y_ moneda para acuñar", etc.

Los contratos `Drop` permiten que el creador del contrato establezca fases (periodos de tiempo), donde cada fase puede especificar múltiples restricciones sobre la acuñación de tokens durante ese periodo de tiempo. Nos referimos a una de estas fases como una ‘condición de reclamo’.

### Por qué estamos construyendo `Drop`

Hemos observado que existen tres contextos distintos bajo los cuales se acuñan tokens —

1. Acuñar tokens para ti mismo en un contrato que posees. Ejemplo: una persona quiere acuñar su foto de perfil de Twitter como un NFT.
2. Hacer que una audiencia acuñe tokens en un contrato que posees.
   1. La naturaleza de los tokens a acuñar por la audiencia está pre-determinada por el administrador del contrato. Ejemplo: una caída de 10k NFT en la que el contenido de los NFT a ser acuñados por la audiencia ya está conocido y determinado por el administrador del contrato antes de que la audiencia venga a acuñar los NFT.
   2. La naturaleza de los tokens a acuñar por la audiencia _no_ está pre-determinada por el administrador del contrato. Ejemplo: un 'certificado' de curso generado dinámicamente con el nombre del participante del curso, para ser acuñado por el participante del curso en el momento de completar el curso.

Los contratos `Token` de thirdweb sirven para los casos descritos en (1) y 2(ii).

Los contratos `Drop` de thirdweb sirven para el caso descrito en 2(i). Están escritos para dar al creador de un contrato un control granular sobre las restricciones en torno a que una audiencia acuñe tokens del mismo contrato (o ‘colección', en el caso de los NFT) durante un período de tiempo extendido.

## Detalles técnicos

El mecanismo de distribución de `Drop` es el siguiente — Un administrador de contrato establece una serie de 'condiciones de reclamo'. Una 'condición de reclamo' es un período de tiempo en el que las cuentas pueden acuñar tokens en el respectivo contrato `Drop`, dentro de un conjunto de restricciones definidas por la 'condición de reclamo'.

### Condiciones de reclamo

Lo siguiente constituye una condición de reclamo —

```solidity
struct ClaimCondition {
  uint256 startTimestamp;
  uint256 maxClaimableSupply;
  uint256 supplyClaimed;
  uint256 quantityLimitPerWallet;
  bytes32 merkleRoot;
  uint256 pricePerToken;
  address currency;
}

```

| Parámetros             | Tipo    | Descripción                                                                                                                                        |
| ---------------------- | ------- | -------------------------------------------------------------------------------------------------------------------------------------------------- |
| startTimestamp         | uint256 | El timestamp unix después del cual se aplica la condición de reclamo. La misma condición de reclamo se aplica hasta el startTimestamp de la siguiente condición de reclamo. |
| maxClaimableSupply     | uint256 | El número total máximo de tokens que pueden ser reclamados bajo la condición de reclamo.                                                          |
| supplyClaimed          | uint256 | En un momento dado, el número de tokens que han sido reclamados bajo la condición de reclamo.                                                     |
| quantityLimitPerWallet | uint256 | El número máximo de tokens que una billetera puede reclamar bajo una condición de reclamo dada.                                                   |
| merkleRoot             | bytes32 | La lista permitida de direcciones que pueden reclamar tokens bajo la condición de reclamo.                                                        |

(Optional) La lista permitida puede especificar límites de cantidad, precio y moneda para las direcciones en la lista, anulando estos valores bajo esa condición de reclamo.

Los parámetros que componen una condición de reclamo pueden combinarse de diferentes maneras para crear restricciones específicas alrededor de una acuñación. Por ejemplo, una única condición de reclamo donde:

- `quantityLimitPerWallet = 5`
- `merkleRoot = bytes32(0)`

crea restricciones alrededor de una acuñación, donde (1) una billetera puede acuñar como máximo 5 tokens y (2) todas las billeteras están sujetas a los límites generales de la condición de reclamo, sin ninguna anulación.

Un contrato `Drop` permite a un administrador de contrato establecer una serie de condiciones de reclamo de una vez. Dado que cada condición de reclamo especifica un `startTime`, un administrador de contrato puede establecer una serie de condiciones de reclamo, ordenadas por su hora de inicio, para especificar diferentes conjuntos de restricciones alrededor de la acuñación, durante diferentes períodos de tiempo.

En cualquier momento, solo hay una condición de reclamo activa, y una cuenta que intente acuñar tokens en el respectivo contrato `Drop` lo hará con éxito o no, según si la cuenta cumple con las restricciones definidas por la condición de reclamo activa en ese momento.

Un contrato `Drop` realiza un seguimiento nativo de las condiciones de reclamo establecidas por un administrador de contrato en una 'lista de condiciones de reclamo', que luce de la siguiente manera —

```solidity
struct ClaimConditionList {
  uint256 currentStartId;
  uint256 count;
  mapping(uint256 => ClaimCondition) conditions;
  mapping(uint256 => mapping(address => uint256)) supplyClaimedByWallet;
}

```
| Parámetro             | Descripción                                                                                                                                                                   |
| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| currentStartId        | El uid para la primera condición de reclamo entre el conjunto actual de condiciones de reclamo. El uid de cada condición de reclamo siguiente es uno más que el uid de la condición anterior. |
| count                 | El número total de condiciones de reclamo en la lista de condiciones de reclamo.                                                                                               |
| conditions            | Las condiciones de reclamo en un uid dado. Las condiciones de reclamo están ordenadas en orden ascendente por su `startTimestamp`.                                             |
| supplyClaimedByWallet | Mapa desde un uid de condición de reclamo y una cuenta hasta el suministro reclamado por esa cuenta.                                                                            |

### Allowlist como lista de sobrescritura

Como se mencionó anteriormente, una allowlist puede especificar diferentes condiciones para las direcciones en la lista. De esta manera, actúa como una sobrescritura sobre las restricciones generales/abiertas para las direcciones no incluidas en la allowlist.
En esta allowlist o lista de sobrescritura, un administrador puede establecer cualquiera de estos tres valores:

- límite de cantidad
- precio
- moneda

Si no se establece un valor para cualquiera de estos, se usará el valor especificado en la condición general de reclamo. Sin embargo, la sobrescritura de la moneda se considerará solo cuando también se establezca una sobrescritura del precio, y no sin ella.

> **IMPORTANTE**: _La allowlist no debe contener una dirección más de una vez en el mismo árbol de Merkle. Las múltiples instancias para la misma dirección (con cantidad, precio, etc., diferentes o iguales) pueden no funcionar como se espera y pueden generar comportamientos inesperados durante el reclamo. (Más detalles en la sección de Limitaciones)._

### Estableciendo condiciones de reclamo

En todos los contratos `Drop`, un administrador de contrato especifica lo siguiente al establecer condiciones de reclamo:

| Parámetro             | Tipo             | Descripción                                                                        |
| --------------------- | ---------------- | ---------------------------------------------------------------------------------- |
| conditions            | ClaimCondition[] | Condiciones de reclamo en orden ascendente por `startTimestamp`.                   |
| resetClaimEligibility | bool             | Si se deben restablecer los valores de `supplyClaimedByWallet` al establecer nuevas condiciones de reclamo. |

Al establecer condiciones de reclamo, cualquier conjunto de condiciones de reclamo existentes almacenadas en `ClaimConditionsList` se sobrescribirá con las nuevas condiciones de reclamo especificadas en `conditions`.

Se espera que las condiciones de reclamo especificadas en `conditions` estén ordenadas en orden ascendente, por su 'hora de inicio'. Como resultado, solo una condición de reclamo está activa en cualquier momento dado.

A cada una de las condiciones de reclamo especificadas en `conditions` se le asigna un ID único de tipo entero. El UID de la primera condición en `conditions` se almacena como `ClaimConditionList.currentStartId` y el UID de cada condición de reclamo siguiente es uno más que el UID de la condición anterior.

<DocImage src={claimConditionsImage} alt="Claim conditions" />

El flag booleano `resetClaimEligibility` determina qué UIDs se asignan a las condiciones de reclamo especificadas en `conditions`. Dado que `ClaimConditionList.supplyClaimedByWallet` se indexa por el UID de las condiciones de reclamo, esto otorga al administrador del contrato un control más granular sobre las restricciones que las condiciones de reclamo pueden expresar. Ahora ilustramos esto con un ejemplo:

Supongamos que una condición de reclamo existente **C1** especifica las siguientes restricciones:

- `quantityLimitPerWallet = 1`
- `merkleRoot = bytes32(0)`
- `pricePerToken = 0.1 ether`
- `currency = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` (i.e. native token of the chain e.g ether for Ethereum mainnet)

A un alto nivel, **C1** expresa las siguientes restricciones sobre el minting: cualquier dirección puede reclamar como máximo un token, en algún momento, pagando 0.1 ether de precio.

Supongamos que el administrador del contrato desea aumentar el precio por token de 0.1 ether a 0.2 ether, mientras asegura que las carteras que ya han reclamado tokens no puedan reclamar tokens nuevamente. Esencialmente, el administrador del contrato ahora quiere instanciar una condición de reclamo **C2** con las siguientes restricciones:

- `quantityLimitPerWallet = 1`
- `merkleRoot = bytes32(0)`
- `pricePerToken = 0.2 ether`
- `currency = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE` (i.e. native token of the chain e.g ether for Ethereum mainnet)

Para pasar de **C1** a **C2** asegurando que las carteras que ya han reclamado tokens no puedan reclamar tokens nuevamente, el administrador del contrato configurará las condiciones de reclamo especificando `resetClaimEligibility == false`. Como resultado, el **C2** se asignará el mismo UID que **C1**. Dado que `ClaimConditionList.supplyClaimedByWallet` está indexado por el UID de las condiciones de reclamo, la información de la cantidad de tokens reclamados por la cartera durante **C1** no se perderá. Por lo tanto, las carteras que reclamaron tokens durante **C1** ahora serán inelegibles para reclamar tokens durante **C2** debido a la siguiente verificación:

```solidity
// pseudo-code
supplyClaimedByWallet = claimCondition.supplyClaimedByWallet[conditionId][claimer];

require(quantityToClaim + supplyClaimedByWallet <= quantityLimitPerWallet);
```

### EIPs soportados / implementados

El mecanismo de distribución de tokens expresado por los `Drop` de thirdweb está implementado para tokens ERC20, ERC721 y ERC1155, como `DropERC20`, `DropERC721` y `DropERC1155`.

Existen algunas diferencias clave entre las tres implementaciones —

- `DropERC20` está escrito para la distribución de tokens completamente fungibles ERC20. Por otro lado, `DropERC721` y `DropERC1155` están escritos para la distribución de NFTs, lo que requiere ‘lazy minting', es decir, definir el contenido de los NFTs antes de que el público venga a acuñarlos durante una condición de reclamo.
- Tanto `DropERC20` como `DropERC721` mantienen una `ClaimConditionsList` global y de contrato, que almacena las condiciones bajo las cuales los tokens pueden ser acuñados. El contrato `DropERC1155`, por otro lado, mantiene una `ClaimConditionList` para cada token ID entero que un NFT puede asumir. Así que, un administrador del contrato puede configurar condiciones de reclamo por NFT, es decir, por token ID, en el contrato `DropERC1155`.

## Limitaciones

### Ataques Sybil

El mecanismo de distribución de los contratos `Drop` de thirdweb es vulnerable a [ataques Sybil](https://en.wikipedia.org/wiki/Sybil_attack). Es decir, a pesar de las diversas formas en que se pueden aplicar restricciones para la acuñación de tokens, algunas restricciones que las condiciones de reclamo pueden expresar están dirigidas a carteras y no a personas.

Por ejemplo, la restricción `quantityLimitPerWallet` expresa la cantidad máxima que una _cartera_ puede reclamar durante la respectiva condición de reclamo. Un actor sofisticado puede generar múltiples carteras para reclamar tokens de una manera que socave tales restricciones, cuando se ven estas restricciones como restricciones sobre personas únicas, y no sobre carteras.

### Comportamiento de la lista blanca (allowlist)

Al especificar la lista blanca de direcciones, cantidades, precios, etc. para esas direcciones, los administradores del contrato deben asegurarse de no listar una dirección más de una vez en el mismo árbol Merkle.

Por ejemplo, si un administrador desea otorgar al usuario X permiso para acuñar 2 tokens a 0.25 ETH y 4 tokens a 0.5 ETH. En este caso, el diseño del contrato no permitirá que el usuario X reclame 6 tokens con precios diferentes como se desea. En cambio, el usuario puede estar limitado a reclamar solo 2 tokens o 4 tokens según el orden en que los reclame.

Para evitar tales inconvenientes, una dirección debe aparecer solo una vez por árbol Merkle o lista blanca.

import { Callout } from "@doc";

# FAQ

## About Engine

### ¿Qué contratos son compatibles con Engine?

Engine es compatible con lecturas y escrituras en cualquier contrato verificado en el explorador de la blockchain, incluidos los contratos desplegados a través de thirdweb.  
_Nota: Algunos puntos finales permiten proporcionar el ABI del contrato para soportar contratos no verificados._

Engine también es compatible con el despliegue de los [contratos predefinidos de thirdweb](https://thirdweb.com/explore), incluidos NFTs, tokens, mercados y cuentas inteligentes.

Si tienes alguna pregunta sobre un tipo de contrato en particular, [contáctanos](https://thirdweb.com/support).

### ¿Cómo se diferencian Engine y el SDK de contratos de thirdweb?

Engine es un servidor que gestiona tus billeteras backend y cómo interactúan con los contratos. Esta diferencia desbloquea capacidades que thirdweb y otros SDKs de web3, incluyendo:

- Gestión de billeteras backend KMS
- Control de acceso detallado con tokens de acceso
- Paralelización de transacciones para manejar un mayor rendimiento por billetera
- Observabilidad y reintentos en transacciones atascadas
- Webhooks en transacciones completadas para sincronizar la actividad onchain y off-chain

Además, Engine está construido sobre el SDK de thirdweb y tiene las mismas capacidades.

## Usando Engine

### ¿Cómo puedo esperar a que una transacción sea minada?

Las llamadas de escritura a contratos no bloquean hasta que se minan. En su lugar, encolan un trabajo asíncrono y devuelven inmediatamente una referencia al trabajo llamada `queueId`.

Aquí hay tres formas de determinar cuándo el trabajo es minado:

- Usa [webhooks](/engine/features/webhooks) para notificar a tu backend cuando ocurra un evento de transacción.
- Haz polling del punto final `/transaction/status/<queue_id>`.
- Usa websockets:

  ```js
  const socket = new WebSocket(
  	"wss://<engine_url>/transaction/status/<queue_id>?token=<session_token>",
  );
  socket.onmessage = (event) => {
  	const res = JSON.parse(event.data);
  	console.log("Received data:", JSON.parse(res.result));
  };
  ```

### ¿Cómo envío moneda nativa con mi transacción?

Para enviar tokens nativos (por ejemplo, ETH en Ethereum), establece `txOverrides.value`.
Esto puede ser necesario cuando se llama a un método `payable` de contrato.

Aquí tienes un ejemplo de cómo enviar 0.2 ETH:


```json
{
  // ...other arguments in the write transaction

  "txOverrides": {
    "value": "200000000000000000"
  }
}
```

### ¿Cómo anulo la configuración de gas?

Para anular la configuración de gas, establece los campos relevantes de `txOverrides`.
Cada campo es opcional y será estimado por Engine si se omite.

Aquí tienes un ejemplo de cómo establecer un límite de gas de 210,000 unidades de gas, una tarifa máxima de 1 gwei y una tarifa máxima de prioridad de 1 gwei:


```json
{
  // ...other arguments in the write transaction

  "txOverrides": {
    "gas": "210000",
    "maxFeePerGas": "1000000000",
    "maxPriorityFeePerGas": "1000000000"
  }
}
```
<Callout variant='warning' title="Es buena idea establecer un tiempo de espera cuando configures un maxFeePerGas.">

De lo contrario, si los precios del gas no bajan, las transacciones pueden quedarse en tu cola indefinidamente.

</Callout>


### ¿Cómo puedo establecer un tiempo de espera en las transacciones?

Para especificar un tiempo de espera en una transacción, configura `txOverrides.timeoutSeconds`.
Engine marcará las transacciones como `errored` si no se envían antes de que se alcance el tiempo de espera. Se enviará un webhook con el estado `errored`.

Nota: Una transacción enviada antes del tiempo de espera puede ser minada después de que haya transcurrido el tiempo.

Aquí tienes un ejemplo de un tiempo de espera de 2 horas:

```json
{
  // ...other arguments in the write transaction

  "txOverrides": {
    "timeoutSeconds": 7200
  }
}
```

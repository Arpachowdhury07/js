import webhooksImage from "../../assets/engine-webhooks.webp";
import { createMetadata, Details, DocImage } from "@doc";

export const metadata = createMetadata({
	title: "Webhooks | thirdweb Engine",
	description:
		"Configure webhooks in Engine to notify your backend server of transaction or backend wallet events.",
});

# Webhooks

Configura webhooks en Engine para notificar a tu servidor backend sobre eventos de transacciones o de billeteras backend.

## Eventos compatibles

### Transacciones

Gestiona cuándo una transacción en blockchain es enviada y minada en la cadena.

| Evento                | Descripción                                                                                                                                                                 |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `sent_transaction`    | Se envía una transacción al RPC. Se proporciona un hash de la transacción, pero es posible que aún no esté minada en la cadena.                                              |
| `mined_transaction`   | Una transacción es minada en la blockchain. **Nota: Es posible que la transacción haya revertido en la cadena. Verifica el campo `onchainStatus` para confirmar si fue exitosa.** |
| `errored_transaction` | No se puede enviar una transacción. Puede haber un error en los parámetros de la transacción, la billetera backend o el servidor.                                            |
| `all_transaction`     | Todos los eventos anteriores.                                                                                                                                               |

<DocImage
	src={webhooksImage}
	alt="Webhooks lifecycle"
	className="max-w-[500px] mx-auto"
/>

El payload de la transacción contiene un campo `status` que puede tener uno de los siguientes valores: `sent`, `mined`, `errored`.

Dependiendo de la transacción, tu backend recibirá una de estas secuencias de webhook:

| Estados de la transacción | Descripción |
|-|-|
| `sent` + `mined` | La transacción fue enviada y minada en la cadena. |
| `errored` | La transacción falló antes de ser enviada. Razones comunes: La transacción falló la simulación, la billetera backend no tiene fondos suficientes, la red está caída u ocurrió otro error interno. También puede ocurrir si una transacción con un límite de gas agotó el tiempo de espera. El campo `errorMessage` proporcionará más detalles. |
| `sent` + `errored` | La transacción fue enviada pero no fue minada en la cadena después de un tiempo determinado. Razones comunes: La transacción fue eliminada del mempool del RPC, otra transacción con el mismo nonce fue minada, o el nonce estaba demasiado adelantado con respecto al nonce en la cadena. |
| `cancelled` | La transacción estaba en la cola (aún no enviada) y fue cancelada. |
| `sent` + `cancelled` | La transacción fue enviada y estaba esperando ser minada, pero fue cancelada. |

**Nota:** Los webhooks pueden llegar en un orden distinto al esperado. Trata los estados posteriores como de mayor prioridad que los anteriores. Por ejemplo, si tu backend recibe un webhook `sent` después de un webhook `mined`, considera esta transacción como `mined`.

### Billeteras

| Evento                    | Descripción                                                                                                                                  |
| ------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------- |
| `backend_wallet_balance` | El saldo de una billetera backend está por debajo de `minWalletBalance`. Para leer o actualizar este valor, llama a `GET/POST /configuration/backend-wallet-balance`. |

## Configuración

### Crear un webhook

1. Visita el [dashboard de Engine](https://thirdweb.com/team/~/~/engine) y selecciona tu Engine.
1. Selecciona la pestaña **Configuration**.
1. Selecciona **Create Webhook**.

Las URLs de los webhooks deben comenzar con `https://`.

## Formato del payload

Método: `POST`

Encabezados:

- `Content-Type: application/json`
- `X-Engine-Signature: <firma del payload>`
- `X-Engine-Timestamp: <marca de tiempo Unix en segundos>`

<Details id="sample-sent-transaction-payload" summary="Ejemplo de transacción enviada">

```json
{
	// Queue details
	"queueId": "1411246e-b1c8-4f5d-9a25-8c1f40b54e55",
	"status": "sent",
	"onchainStatus": null,
	"queuedAt": "2023-09-29T22:01:31.031Z",
	"sentAt": "2023-09-29T22:01:41.580Z",
	"minedAt": null,
	"errorMessage": null,
	"cancelledAt": null,
	"retryCount": 0,

	// Onchain details
	"chainId": 80001,
	"fromAddress": "0x3ecdbf3b911d0e9052b64850693888b008e18373",
	"toAddress": "0x365b83d67d5539c6583b9c0266a548926bf216f4",
	"data": "0xa9059cbb0000000000000000000000003ecdbf3b911d0e9052b64850693888b008e183730000000000000000000000000000000000000000000000000000000000000064",
	"value": "0x00",
	"nonce": 1786,
	"gasLimit": "39580",
	"maxFeePerGas": "2063100466",
	"maxPriorityFeePerGas": "1875545856",
	"gasPrice": "1875545871",
	"transactionType": null,
	"transactionHash": "0xc3ffa42dd4734b017d483e1158a2e936c8a97dd1aa4e4ce11df80ac8e81d2c7e",
	"sentAtBlockNumber": 40660021,
	"blockNumber": null,

	// User operation (account abstraction) details
	"signerAddress": null,
	"accountAddress": null,
	"target": null,
	"sender": null,
	"initCode": null,
	"callData": null,
	"callGasLimit": null,
	"verificationGasLimit": null,
	"preVerificationGas": null,
	"paymasterAndData": null,
	"userOpHash": null,

	// Off-chain details
	"functionName": "transfer",
	"functionArgs": "0x3ecdbf3b911d0e9052b64850693888b008e18373,100",
	"extension": "none",
	"deployedContractAddress": null,
	"deployedContractType": null
}
```

</Details>

<Details id="sample-mined-transaction-payload" summary="Ejemplo de transacción confirmada">

Tip: Verifique el campo `onchainStatus`. "success" significa que la transacción se minó en la cadena sin errores. "reverted" significa que la transacción o el UserOp fue revertido.

```json
{
	// Queue details
	"queueId": "1411246e-b1c8-4f5d-9a25-8c1f40b54e55",
	"status": "mined",
	"onchainStatus": "success",
	"queuedAt": "2023-09-29T22:01:31.031Z",
	"sentAt": "2023-09-29T22:01:41.580Z",
	"minedAt": "2023-09-29T22:01:44.000Z",
	"errorMessage": null,
	"cancelledAt": null,
	"retryCount": 0,

	// Onchain details
	"chainId": 80001,
	"fromAddress": "0x3ecdbf3b911d0e9052b64850693888b008e18373",
	"toAddress": "0x365b83d67d5539c6583b9c0266a548926bf216f4",
	"data": "0xa9059cbb0000000000000000000000003ecdbf3b911d0e9052b64850693888b008e183730000000000000000000000000000000000000000000000000000000000000064",
	"value": "0x00",
	"nonce": 1786,
	"gasLimit": "39580",
	"maxFeePerGas": "2063100466",
	"maxPriorityFeePerGas": "1875545856",
	"gasPrice": "1875545871",
	"transactionType": 2,
	"transactionHash": "0xc3ffa42dd4734b017d483e1158a2e936c8a97dd1aa4e4ce11df80ac8e81d2c7e",
	"sentAtBlockNumber": 40660021,
	"blockNumber": 40660026,

	// User operation (account abstraction) details
	"signerAddress": null,
	"accountAddress": null,
	"target": null,
	"sender": null,
	"initCode": null,
	"callData": null,
	"callGasLimit": null,
	"verificationGasLimit": null,
	"preVerificationGas": null,
	"paymasterAndData": null,
	"userOpHash": null,

	// Off-chain details
	"functionName": "transfer",
	"functionArgs": "0x3ecdbf3b911d0e9052b64850693888b008e18373,100",
	"extension": "none",
	"deployedContractAddress": null,
	"deployedContractType": null
}
```

</Details>

## Verificación del Webhook (recomendado)

Dado que cualquier origen externo puede llamar a su punto final del webhook, se recomienda verificar la firma del webhook para asegurarse de que la solicitud provenga de su instancia de Engine.

### Verificar la firma

El cuerpo del payload está firmado con el secreto del webhook y se proporciona en el encabezado de solicitud `X-Engine-Signature`.

Obtenga el **secreto del webhook** para su punto final desde el panel de control.

Este ejemplo de código verifica si la firma es válida:

```ts
const generateSignature = (
	body: string,
	timestamp: string,
	secret: string,
): string => {
	const payload = `${timestamp}.${body}`;
	return crypto.createHmac("sha256", secret).update(payload).digest("hex");
};

const isValidSignature = (
	body: string,
	timestamp: string,
	signature: string,
	secret: string,
): boolean => {
	const expectedSignature = generateSignature(body, timestamp, secret);
	return crypto.timingSafeEqual(
		Buffer.from(expectedSignature),
		Buffer.from(signature),
	);
};
```

### Verificar la marca de tiempo

La marca de tiempo del evento se proporciona en el encabezado de solicitud `X-Engine-Timestamp`.

Este ejemplo de código verifica si el evento excede la duración de expiración dada:

```ts
export const isExpired = (
	timestamp: string,
	expirationInSeconds: number,
): boolean => {
	const currentTime = Math.floor(Date.now() / 1000);
	return currentTime - parseInt(timestamp) > expirationInSeconds;
};
```

### Ejemplo de endpoint de webhook

Este ejemplo de código en NodeJS escucha las notificaciones de eventos en el endpoint `/webhook`:

```ts
import express from "express";
import bodyParser from "body-parser";
import { isValidSignature, isExpired } from "./webhookHelper";

const app = express();
const port = 3000;

const WEBHOOK_SECRET = "<your_webhook_auth_secret>";

app.use(bodyParser.text());

app.post("/webhook", (req, res) => {
	const signatureFromHeader = req.header("X-Engine-Signature");
	const timestampFromHeader = req.header("X-Engine-Timestamp");

	if (!signatureFromHeader || !timestampFromHeader) {
		return res.status(401).send("Missing signature or timestamp header");
	}

	if (
		!isValidSignature(
			req.body,
			timestampFromHeader,
			signatureFromHeader,
			WEBHOOK_SECRET,
		)
	) {
		return res.status(401).send("Invalid signature");
	}

	if (isExpired(timestampFromHeader, 300)) {
		// Assuming expiration time is 5 minutes (300 seconds)
		return res.status(401).send("Request has expired");
	}

	// Process the request
	res.status(200).send("Webhook received!");
});

app.listen(port, () => {
	console.log(`Server started on http://localhost:${port}`);
});
```
